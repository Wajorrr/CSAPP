## Lab5-Cache Lab

### Part A: Writing a Cache Simulator

In Part A you will write a cache simulator in `csim.c` that takes a valgrind memory trace as input, simulates the hit/miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions.

![](./assets/5.%20lab5-Cache%20Lab/2023-08-14-15-48-08.png)
![](./assets/5.%20lab5-Cache%20Lab/2023-08-14-15-48-55.png)

这一部分就是要在`csim.c`中写一个缓存模拟器，要求对于指定的trace，输出与给定的缓存模拟器可执行文件一样的信息

可选参数的介绍中提到了几个概念，并标明了在书上有相关介绍，先看看

* `-s <s>`：Number of set index bits ($S = 2^s$is the number of sets)
* `-E <E>`：Associativity (number of lines per set)
* `-b <b>`：Number of block bits ($B = 2^b$ is the block size)

![](./assets/5.%20lab5-Cache%20Lab/2023-08-14-15-56-56.png)

`Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>`

这里-s参数指定的就是此缓存**具有$2^s$个缓存组**，-E参数指定的就是**每个缓存组包含E个缓存行**，-b参数指定的就是**每个缓存行包含$2^b$个字节**

再来看看给定的例子中用到的yi.trace文件：
```
 L 10,1
 M 20,1
 L 22,1
 S 18,1
 L 110,1
 L 210,1
 M 12,1
```
![](./assets/5.%20lab5-Cache%20Lab/2023-08-14-18-14-55.png)

指定参数 -s 4 -E 1 -b 4 后，是如何对这个trace得到给定的结果的呢？

```
L 10,1 miss
M 20,1 miss hit
L 22,1 hit
S 18,1 hit
L 110,1 miss eviction
L 210,1 miss eviction
M 12,1 miss eviction hit
hits:4 misses:5 evictions:3
```

可以看到这里指定的缓存读取方式**并非实现缓存置换算法时常见到的kv查找方式**，而是**给定一个主存地址，然后指定一个size**，表示**从这个主存地址处读取size大小的内容**，这就需要去再了解下如何将这样的获取指令转化为对缓存的读取了，再去书上找

![](./assets/5.%20lab5-Cache%20Lab/2023-08-14-17-48-03.png)

于是我们可以模拟一下，-s 4 -E 1 -b 4 代表缓存具有16个缓存组，每个缓存组有1个缓存行，每个缓存行有16个字节

因此一个主存地址会包含 t+4+4 位，t为标记位长度

当执行L load data时，相当于直接查找缓存，反馈缓存是否miss，miss则将数据读入缓存；执行S store时，和查找缓存一样，都是检查缓存，反馈是否miss，miss则将数据读入缓存；执行M modify时，相当于先查找，若存在则直接修改，否则在数据读入缓存后再修改；I 表示load指令，在这里我们忽略指令加载开销，因此忽略I指令

接下来逐指令分析一下样例结果：

1. L 10,1 miss
    * 0x10=0b0001 0000，组索引=1，偏移位=0，size=1，**miss**，缓存组1的行生效，缓存了 0b0001 0000~0b0001 1111=>`0x10~0x1f` 的数据
2. M 20,1 miss hit
    * 0x20=0b0010 0000，组索引=2，偏移位=0，size=1，**miss**，缓存组2的行生效，缓存了 `0x20~0x2f` 的数据
    * 由于操作是modify，miss后读入缓存后，**hit**
3. L 22,1 hit
    * 0x22=0b0010 0010，组索引=2，偏移位=2，size=1，缓存组2的行已生效，且标记位相同，**hit**
4. S 18,1 hit
    * 0x18=0b0001 1000，组索引=1，偏移位=8，size=1，缓存组1的行已生效，且标记位相同，**hit**
5. L 110,1 miss eviction
    * 0x110=0b1 0001 0000，标记位=1，组索引=1，偏移位=0，size=1，缓存组1的行已生效，**但这里标记位为1，与缓存行的0不同**，同时也可以看到前面分析的缓存行缓存的是`0x10~0x1f`，因此**miss，需要执行缓存替换**，**eviction**，**替换后此时缓存行1的标记位为1**，缓存的数据为 0b1 0001 0000~0b1 0001 1111=>`0x110~0x11f`
6. L 210,1 miss eviction
    * 0x210=0b10 0001 0000，标记位=2，组索引=1，偏移位=0，和上一个指令的情况一样，**miss**，缓存组1的行执行缓存替换，**eviction**，替换后标记位变为2，缓存的数据为`0x210~0x21f`
7. M 12,1 miss eviction hit
    * 0x12=0b0001 0010，标记位=0，组索引=1，偏移位=2，由于此时缓存组1的行标记位=2，因此**miss**，执行缓存替换，**eviction**，替换后标记位变为0，缓存的数据为`0x10~0x1f`
    * 由于是modify，缓存替换后**hit**

结果：hits:4 misses:5 evictions:3

> 感慨：在此之前自己曾经看过一些介绍组相联、级相连映射这样的知识的一些文章，但是一直都不是真正的理解了，直到现在分析了这里的例子，才感觉自己好像真的懂这个东西是什么了，只想说，概念性的东西终究是概念性的东西，不回归到实际情况进行理解，真的可能就一直都是一知半解，或者错误理解。。。这就像是主观与客观，概念都是人主观的总结，换个人去看这些概念的时候总是会容易因为知识储备不同，而出现一些理解偏差，导致无法理解或者错误理解；而代码、实际的运行结果这些事实，就是客观的东西，针对这些东西进行分析理解，永远都是更加精确的(前提是具备正确分析抽象的结果的能力😂)

可以看出，这种缓存方式实际上就是**针对内存地址进行了一个分组**，不同缓存组对不同范围的内存地址分别进行缓存，**给定了内存地址，其只能被唯一指定好的一个组进行缓存**，而**组中可能会有多个行，这些行就只相当于每个组的缓存空间，并不对应特定内存地址空间**，每个行能缓存多大范围的地址也是被设定好的，而**对于组中的行就是采用缓存替换策略来进行重复使用的**

这样就针对缓存组、缓存行分别写个结构体或者类，然后实现处理指令和缓存替换以及输出信息的功能就可以了

我的代码：
```cpp
#include "cachelab.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct cache_line
{
    int valid;         // 有效位
    int tag;           // 标记位
    int last_vis_time; // 最近一次访问时间戳
    char *data_;
} cache_line_;
typedef struct cache_set
{
    cache_line_ *cache_line;
} cache_set_;
typedef struct cache
{
    int S; // 包含S个缓存组
    int E; // 每个缓存组包含的缓存行数量
    int B; // 每个缓存行包含的字节数量
    cache_set_ *cache_set;
} cache_;

void init(cache_ *cache, int s, int E, int b) // C语言没有构造函数，只能单独定义一个初始化函数
{
    cache->S = 1 << s;
    cache->E = E;
    cache->B = 1 << b;
    cache->cache_set = (cache_set_ *)malloc(sizeof(cache_set_) * cache->S); // 为S个缓存组申请内存
    for (int i = 0; i < cache->S; i++)
    {
        // 为每个组的E个缓存行申请内存
        cache->cache_set[i].cache_line = (cache_line_ *)malloc(sizeof(cache_line_) * cache->E);
        // 缓存行初始化，并为每个缓存行的数据块申请内存
        for (int j = 0; j < cache->E; j++)
        {
            // 本lab中不涉及实际的数据存储，因此不需要给缓存行的数据块申请空间
            // cache->cache_set[i].cache_line[j].data_ = (char *)malloc(sizeof(char) * cache->B);
            cache->cache_set[i].cache_line[j].valid = 0;
            cache->cache_set[i].cache_line[j].tag = 0;
            cache->cache_set[i].cache_line[j].last_vis_time = 0;
        }
    }
}
void del(cache_ *cache)
{
    for (int i = 0; i < cache->S; i++)
    {
        // // 释放每个缓存行的数据块空间
        // for (int j = 0; j < cache->E; j++)
        // {
        //     free(cache->cache_set[i].cache_line[j].data_);
        // }

        // 释放每个缓存组的缓存行空间
        free(cache->cache_set[i].cache_line);
    }
    free(cache->cache_set); // 释放缓存组空间
    free(cache);            // 释放缓存指针
}

// 定义完了数据结构以及初始化、删除函数，接下来把查找缓存、缓存替换需要的函数定义一下

// 查找缓存，参数为缓存组指针cache_set，标记位tag
int find(cache_ *cache, int set_index, int tag, int time)
{
    for (int i = 0; i < cache->E; i++)
    {
        if (cache->cache_set[set_index].cache_line[i].valid &&
            cache->cache_set[set_index].cache_line[i].tag == tag)
        {
            cache->cache_set[set_index].cache_line[i].last_vis_time = time;
            return 1;
        }
    }
    return 0;
}
int IsFull(cache_ *cache, int set_index) // 判断cache的编号为set_index的缓存组是否已满
{
    for (int i = 0; i < cache->E; i++)
    {
        if (cache->cache_set[set_index].cache_line[i].valid == 0)
            return 0;
    }
    return 1;
}
// 缓存驱逐，参数为缓存组指针cache_set
int evict(cache_ *cache, int set_index)
{ // 最高效的写法应该用哈希表+双向链表，但是这里只能用c语言，hash表需要自己实现，就先直接通过遍历上一次时间戳来实现了
    int min_time = 0x3f3f3f3f, evict_idx = 0;
    for (int i = 0; i < cache->E; i++)
    {
        if (cache->cache_set[set_index].cache_line[i].last_vis_time < min_time)
        {
            min_time = cache->cache_set[set_index].cache_line[i].last_vis_time;
            evict_idx = i;
        }
    }
    return evict_idx;
}
// 数据加载到缓存，参数为缓存组指针cache_set，标记位tag
int insert(cache_ *cache, int set_index, int tag, int time)
{
    int line_idx = 0;
    if (IsFull(cache, set_index))
    {
        line_idx = evict(cache, set_index);
        cache->cache_set[set_index].cache_line[line_idx].tag = tag;
        cache->cache_set[set_index].cache_line[line_idx].last_vis_time = time;
        return 1;
    }
    for (int i = 0; i < cache->E; i++)
    {
        if (cache->cache_set[set_index].cache_line[i].valid == 0)
        {
            line_idx = i;
            break;
        }
    }
    cache->cache_set[set_index].cache_line[line_idx].valid = 1;
    cache->cache_set[set_index].cache_line[line_idx].tag = tag;
    cache->cache_set[set_index].cache_line[line_idx].last_vis_time = time;
    return 0;
}

// 写出了缓存需要的函数定义后，先不着急实现，先对把对trace指令的读取处理实现一下
int change2num(char *s)
{
    int res = 0;
    for (int i = 0; s[i]; i++)
    {
        res *= 10;
        res += s[i] - '0';
    }
    return res;
}

void solveTrace(int s, int E, int b, FILE *fp)
{
    cache_ *cache;
    cache = (cache_ *)malloc(sizeof(cache_));
    init(cache, s, E, b);
    int hit = 0, miss = 0, eviction = 0;
    int time = 0; // 时间戳

    // 处理文件输入
    char opt[31];
    // fgets(char* s,int n,FILE *stream) 从stream读取字符串，读取到n个字符，或者读取到一行末尾，或者读取到文件末尾则结束
    while (fgets(opt, 30, fp))
    {
        time++;
        // printf("%s", opt);
        char c[2];
        int addr, size;
        sscanf(opt, "%s %x,%d", c, &addr, &size);
        // printf("%s %d %d\n", c, addr, size);

        int tag = addr >> (s + b);                                  // 标记位
        int set_index = (addr >> b) & ((unsigned)(-1) >> (32 - s)); // 组编号

        if (c[0] == 'L' || c[0] == 'S')
        {
            if (find(cache, set_index, tag, time))
            {
                hit++;
                printf("%s %x,%d hit\n", c, addr, size);
            }
            else
            {
                miss++;
                printf("%s %x,%d miss ", c, addr, size);
                if (insert(cache, set_index, tag, time))
                {
                    eviction++;
                    printf("eviction");
                }
                printf("\n");
            }
        }
        else if (c[0] == 'M')
        {
            if (find(cache, set_index, tag, time))
            {
                hit += 2;
                printf("%s %x,%d hit hit\n", c, addr, size);
            }
            else
            {
                miss++;
                printf("%s %x,%d miss ", c, addr, size);
                if (insert(cache, set_index, tag, time))
                {
                    eviction++;
                    printf("eviction ");
                }
                hit++;
                printf("hit\n");
            }
        }
    }
    printSummary(hit, miss, eviction);
    del(cache);
}

void solve(int argc, char *argv[])
{
    int s, E, b;
    FILE *fp; // 文件指针
    for (int i = 1; i < argc; i++)
    {
        // printf("%d %s\n", i, argv[i]);
        if (argv[i][0] == '-')
        {
            if (argv[i][1] == 's')
            {
                i++;
                s = change2num(argv[i]);
            }
            else if (argv[i][1] == 'E')
            {
                i++;
                E = change2num(argv[i]);
            }
            else if (argv[i][1] == 'b')
            {
                i++;
                b = change2num(argv[i]);
            }
            else if (argv[i][1] == 't')
            {
                i++;
                printf("%s\n", argv[i]);
                fp = fopen(argv[i], "r");
            }
        }
    }
    solveTrace(s, E, b, fp);
}

int main(int argc, char *argv[]) // argc为参数数量、argv为参数，其中argv[0]为程序名
{
    solve(argc, argv);
    // printSummary(0, 0, 0);
    return 0;
}
```

测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 1 -E 1 -b 1 -t traces/yi2.trace
traces/yi2.trace
hits:9 misses:8 evictions:6
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 1 -E 1 -b 1 -t traces/yi2.trace
hits:9 misses:8 evictions:6

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 4 -E 2 -b 4 -t traces/yi.trace
traces/yi.trace
hits:4 misses:5 evictions:2
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 4 -E 2 -b 4 -t traces/yi.trace
hits:4 misses:5 evictions:2

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 2 -E 1 -b 4 -t traces/dave.trace
traces/dave.trace
hits:2 misses:3 evictions:1
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 2 -E 1 -b 4 -t traces/dave.trace
hits:2 misses:3 evictions:1

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 2 -E 1 -b 3 -t traces/trans.trace
traces/trans.trace
hits:167 misses:71 evictions:67
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 2 -E 1 -b 3 -t traces/trans.trace
hits:167 misses:71 evictions:67

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 2 -E 2 -b 3 -t traces/trans.trace
traces/trans.trace
hits:201 misses:37 evictions:29
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 2 -E 2 -b 3 -t traces/trans.trace
hits:201 misses:37 evictions:29

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 2 -E 4 -b 3 -t traces/trans.trace
traces/trans.trace
hits:212 misses:26 evictions:10
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 2 -E 4 -b 3 -t traces/trans.trace
hits:212 misses:26 evictions:10

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 5 -E 1 -b 5 -t traces/trans.trace
traces/trans.trace
hits:231 misses:7 evictions:0
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 5 -E 1 -b 5 -t traces/trans.trace
hits:231 misses:7 evictions:0

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim -s 5 -E 1 -b 5 -t traces/long.trace
traces/long.trace
hits:265189 misses:21775 evictions:21743
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -s 5 -E 1 -b 5 -t traces/long.trace
hits:265189 misses:21775 evictions:21743

root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27

TEST_CSIM_RESULTS=27
```

### Part B: Optimizing Matrix Transpose

在`trans.c`文件中实现矩阵转置函数，尽量使其运行时缓存的miss次数尽可能少，测试样例包括32×32、64×64以及61×67三种矩阵，可以分别对三种矩阵单独编写函数做优化

![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-15-41-15.png)

要求：
* 最多只能使用12个临时变量
* 不能修改数组A，可以修改数组B

trans.c中已经给定了一个矩阵转置函数的简单样例：
```cpp
char trans_desc[] = "Simple row-wise scan transpose";
void trans(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, tmp;

    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
        {
            tmp = A[i][j];
            B[j][i] = tmp;
        }
    }
}
```

#### 32×32

测试：
The autograder takes the matrix size as input. It uses *valgrind* to generate a trace of each registered transpose function. It then evaluates each trace by running the reference simulator on a cache with parameters (s = 5, E = 1, b = 5).
For example, to test your registered transpose functions on a 32 × 32 matrix, rebuild *test-trans*, and then run it with the appropriate values for M and N:
```shell
linux> make
linux> ./test-trans -M 32 -N 32
Step 1: Evaluating registered transpose funcs for correctness:
func 0 (Transpose submission): correctness: 1
func 1 (Simple row-wise scan transpose): correctness: 1
func 2 (column-wise scan transpose): correctness: 1
func 3 (using a zig-zag access pattern): correctness: 1
Step 2: Generating memory traces for registered transpose funcs.
Step 3: Evaluating performance of registered transpose funcs (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1766, misses:287, evictions:255
func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151
func 2 (column-wise scan transpose): hits:870, misses:1183, evictions:1151
func 3 (using a zig-zag access pattern): hits:1076, misses:977, evictions:945
Summary for official submission (func 0): correctness=1 misses=287
```

In this example, we have registered four different transpose functions in trans.c. The test-trans program tests each of the registered functions, displays the results for each, and extracts the results for the official submission.

运行了./test-trans后，会生成对trans.c中指定函数的trace，对funi的trace命名为 `trace.fi`，可以使用part A中的缓存模拟器去对生成的trace进行模拟，从而得到是哪些地方出现了miss：

```shell
linux> ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0
S 68312c,1 miss
L 683140,8 miss
L 683124,4 hit
L 683120,4 hit
L 603124,4 miss eviction
S 6431a0,4 miss
...
```

![](./assets/5.%20lab5-Cache%20Lab/2023-08-15-14-55-08.png)

先直接运行一次样例函数，得到trace1，然后看看能不能分析出来一些信息

```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# make
# Generate a handin tar file each time you compile
tar -cvf root-handin.tar  csim.c trans.c
csim.c
trans.c
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./test-trans -M 32 -N 32

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:869, misses:1184, evictions:1152

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152

Summary for official submission (func 0): correctness=1 misses=1184

TEST_TRANS_RESULTS=1:1184
```
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f1
```
![](./assets/5.%20lab5-Cache%20Lab/2023-08-15-15-05-21.png)

可以看到，除了前4行比较特殊外，后面十分有规律，橙色框框起来的指令和绿色框框起来的指令交错出现，橙色指令全部为load，且访问的内存地址之间均相差0x4，而绿色指令全部为store，访问的内存地址之前均相差0x80

再回顾一下样例程序
```cpp
void trans(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, tmp;

    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
        {
            tmp = A[i][j];
            B[j][i] = tmp;
        }
    }
}
```

N和M均为32，很明显两条交错出现的指令和N、M无关，那就应当是`tmp = A[i][j];B[j][i] = tmp;`这两句了，load是从内存加载到缓存，对应`tmp=A[i][j]`，且地址增量为0x4，也正好对应这个循环里面内循环是j在不断++，对于A[i][j]来说是4个字节4个字节顺序访问的，而store是从缓存存储到内存，对应`B[j][i]=tmp`，j++对于B[j][i]来说是每次跳过了32个元素进行访问的，32*4正好对应地址增量0x80

现在来看看什么情况下出现了缓存miss

由于s=5，E=1，b=5是预先设定好的，即共有32个缓存组，每个缓存组有一个缓存行，**每个缓存行有32个字节，可以想到每当访问到某一个32字节的连续内存时，第一个4字节miss之后，后面若继续连续访问，则后面7个4字节都可以命中**，观察一下，命中情况也确实如此，**对于load命令，大部分情况下每8次都是命中7次，还有一些情况是store命令与load命令的缓存组冲突了**，从而把load命令的缓存给置换了出去

而对于store命令，**每次访问都是相隔128个字节，即相差4个缓存组，而每当8次访问，回到第一次访问时所在的缓存组时，已经和上次访问这个组时相距了1024字节，又需要重新加载数据到缓存**，因此**全部miss了**，不仅如此，每次miss时将其加载到缓存中还造成了缓存污染，导致load命令的缓存命中率降低

观察地址信息还可以发现，**B数组和A数组中下标相同的元素**对应的**缓存组**和**偏移量**都是**相同**的，只是**标记位不同**，因此我们还可以计算一下B数组导致了A数组多了多少次miss

**访问B数组时全部miss**，共32×32=**1024个**

**A数组每8个元素有一次冷不命中**，共1024/8=**128个**

B数组每次跳4个缓存组进行访问，A数组每次访问矩阵一整行，会访问到4个缓存组，B数组访问一整列，会访问到8个缓存组，例如对于第1行，设第1行前8个元素对应的缓存行为0，则A访问到缓存行0、1、2、3，B访问到0、4、8、12、16、20、24、28

A数组每访问8行，即访问8×32×4=32×32个字节，就会再次访问到最开始的缓存组，例如，设第1行前8个元素对应的缓存行为0，则A数组访问到第9行时，前8个元素对应的缓存行也为0，访问到缓存行0、1、2、3，而B访问到1、5、9、13、17、21、25、29

**A数组每次访问一行，B数组每次访问一列**，B数组中**总会访问到一个和A数组坐标重叠的元素**，即**对角线位置的元素**，它们的缓存组相同，从而导致缓存刷新一次，使得A数组多了一次miss

这样导致A数组**多miss了32次**，但是还要减去**除了处于对角线，且处于一个缓存组末尾的那几个元素(下图中标蓝的位置，这几个位置都处于一个缓存组的末尾，先load A数组的值，再store到B数组之后，A数组就不再访问这个缓存组了，不会再产生冲突未命中)，一共4个**，因此冲突导致A数组多miss了**28次**
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-14-21-19.png)

1024+128+28=**1180次**，对应了前面的结果：`func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152`，还有4次是开头的3个和末尾的1个与循环无关的指令造成的miss

![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-14-17-31.png)
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-14-18-10.png)

既然是不连续的内存访问造成的miss，就要想办法让内存访问变成顺序的，于是我们首先要观察一下矩阵转置前后元素的位置变化情况

设矩阵行数为n，列数为m，实际在内存中是一长条n\*m个元素顺序存放的，可以把这一长条分为n组，每组m个元素，转置就是让第i组的第j个元素移动到第j组的第i个位置，移动前和移动后的地址之间相差(j-i)\*m+i+m-j=(j-i)\*(m-1)+m=(j-i+1)\*(m-1)+1

i和j越接近，访问到的元素移动前后位置越接近，即距对角线的距离越近，移动前后两个位置的地址越近

那么沿着对角线方向赋值呢？即从左上到右下，i++,j++，从右下到左上，i--,j--

即一个矩阵从n,0开始遍历，另一个从0,m开始遍历
坐标变化顺序：
n,0 -> 
n,1 -> n-1,0 -> 
n-2,0 -> n-1,1 -> n,2 ->
n,3 -> n-1,2 -> n-2,1 -> n-3,0 ->
n-4,0 -> n-3,1 -> n-2,2 -> n-1,3 -> n,4 ->
...

地址的变化：
+4
-(m+1)\*4、-m\*4
+(m+1)\*4、+(m+1)\*4、+4
-(m+1)\*4、-(m+1)\*4、-(m+1)\*4、-m\*4
+(m+1)\*4、+(m+1)\*4、+(m+1)\*4、+(m+1)\*4、+4
...

画个图看看

![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-10-36-16.png)

额。。结果就是什么都没分析出来，不过这个图也体现出了一点东西，**若矩阵中每行元素数量不等于一个缓存行能缓存的元素数量的整数倍，这样很多地方并不是对齐的**，又要如何处理

沿对角线只能保证A矩阵和B矩阵的访问模式基本一样，但是并不能让顺序访问数量增加，对于增大缓存命中率不一定有好处

看了下知乎，然后又去把lab给的补充材料看了，好像是自己的思路偏了，**不应该总想着怎么去构造产生尽可能多的顺序访问**，B数组miss的**本质原因在于访问的地址跨度过大**，导致**缓存容纳不下**，**每个循环周期都miss以及刷新**，优化的关键点而是在于**给矩阵分块**，不管每行每列地址怎么变化，**主要聚焦于某一块，让缓存每次缓存一整块可以容纳得下的子矩阵**

前面分析miss数量也发现了，对于A数组的顺序访问没有什么办法优化了，要优化的主要在于B数组的miss，以及B数组对A数组造成的miss

**分块介绍**：
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-11-40-21.png)
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-11-41-44.png)
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-11-43-02.png)
```cpp
void bijk(array A, array B, array C, int n, int bsize)
{
    int i, j, k, kk, jj;
    double sum;
    int en = bsize * (n/bsize); /* Amount that fits evenly into blocks */

    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            C[i][j] = 0.0;

    for (kk = 0; kk < en; kk += bsize) 
    {
        for (jj = 0; jj < en; jj += bsize) 
        {
            for (i = 0; i < n; i++) 
            {
                for (j = jj; j < jj + bsize; j++) 
                {
                    sum = C[i][j];
                    for (k = kk; k < kk + bsize; k++) 
                    {
                        sum += A[i][k]*B[k][j];
                    }
                    C[i][j] = sum;
                }
            }
        }
    }
}
```
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-11-43-14.png)
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-11-49-40.png)

总而言之，对矩阵的分块就是**根据缓存的大小来确定矩阵分块大小**，然后通过一次缓存一整块矩阵，一次对一整块矩阵进行处理，增大空间局部性(以及可能增大时间局部性)

回到矩阵转置问题上，要使得B数组不miss，我们可以直接将矩阵分块后进行转置，在保证缓存可以容纳的大小下进行操作

32个缓存组，每个可以容纳32字节，共32×32字节=16×16个4字节，而由于需要同时缓存A数组和B数组，因此**可以选取8×8大小进行分块**(列数需要为一个缓存行能容纳元素数量(8)的整数倍、行数和列数均需要尽量能整除矩阵的总行数和总列数)

代码：
```cpp
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, k, l;

    for (i = 0; i < N; i += 8)
    {
        for (j = 0; j < M; j += 8)
        {
            for (k = i; k < i + 8; k++)
            {
                for (l = j; l < j + 8; l++)
                {
                    B[l][k] = A[k][l];
                }
            }
        }
    }
}
```

测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./test-trans -M 32 -N 32

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1709, misses:344, evictions:312

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152

Summary for official submission (func 0): correctness=1 misses=344

TEST_TRANS_RESULTS=1:344
```

```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0
S 10c080,1 miss
L 18c0c0,8 miss
L 18c0a4,4 miss
L 18c0a0,4 hit
# 从这里循环开始

L 10c0a0,4 miss eviction # A数组第1行第1个元素，缓存组0(假设的，没有专门去对照地址计算实际的缓存组编号，后面的缓存组编号以此类推)，冷不命中
S 14c0a0,4 miss eviction # B数组第1行第1个元素，冷不命中，缓存组0，将A数组的缓存驱逐了出去
L 10c0a4,4 miss eviction # A数组第1行第2个元素，缓存组0，由于与B数组的冲突导致未命中
S 14c120,4 miss # B数组第2行第1个元素，缓存组4，冷不命中
L 10c0a8,4 hit
S 14c1a0,4 miss # B数组第3行第1个元素，缓存组8，冷不命中
L 10c0ac,4 hit
S 14c220,4 miss # B数组第4行第1个元素，缓存组12，冷不命中
L 10c0b0,4 hit
S 14c2a0,4 miss # B数组第5行第1个元素，缓存组16，冷不命中
L 10c0b4,4 hit
S 14c320,4 miss # B数组第6行第1个元素，缓存组20，冷不命中
L 10c0b8,4 hit
S 14c3a0,4 miss # B数组第7行第1个元素，缓存组24，冷不命中
L 10c0bc,4 hit
S 14c420,4 miss # B数组第8行第1个元素，缓存组28，冷不命中

L 10c120,4 miss eviction # A数组第2行第1个元素，缓存组4，冷不命中
S 14c0a4,4 miss eviction # B数组第9行第1个元素，缓存组0，由于和A数组的冲突，现在再次冷不命中
L 10c124,4 hit 
S 14c124,4 miss eviction # B数组第10行第1个元素，缓存组4，将A数组的缓存驱逐了出去
L 10c128,4 miss eviction # A数组第2行第2个元素，缓存组4，由于与B数组的冲突导致未命中
S 14c1a4,4 hit
L 10c12c,4 hit
S 14c224,4 hit
L 10c130,4 hit
S 14c2a4,4 hit
L 10c134,4 hit
S 14c324,4 hit
L 10c138,4 hit
S 14c3a4,4 hit
L 10c13c,4 hit
S 14c424,4 hit

L 10c1a0,4 miss eviction
S 14c0a8,4 hit
L 10c1a4,4 hit
S 14c128,4 miss eviction
L 10c1a8,4 hit
S 14c1a8,4 miss eviction
L 10c1ac,4 miss eviction
```

再来**分析一下miss数量**，我们假设第1行的前8个元素的地址对应缓存组0(按实际地址计算，对应的应当是缓存组5(0b00101)，但这里只是为了分析，将编号以此类推，方便分析即可)

1. 对于第一行8个元素，A数组访问了缓存组0，B数组分别访问了缓存组0、4、8、12、16、20、24、28
    * A数组出现一次冷不命中和一次由与B数组的缓存组冲突造成的miss
    * B数组全部冷不命中

2. 对于第二行8个元素，A数组访问了缓存组4，B数组分别访问了缓存组0、4、8、12、16、20、24、28
    * A数组出现一次冷不命中和一次由与B数组的缓存组冲突造成的miss
    * B数组由于前一行和A数组出现的缓存组冲突，现在再次产生一次miss，然后由于本行和A数组出现的缓存组冲突，产生一次miss
3. 对于第三行8个元素，A数组访问了缓存组8，B数组分别访问了缓存组0、4、8、12、16、20、24、28
    * A数组出现一次冷不命中和一次由与B数组的缓存组冲突造成的miss
    * B数组由于前一行和A数组出现的缓存组冲突，现在再次产生一次miss，由于本行和A数组出现的缓存组冲突，产生一次miss
4. ...
...

可以发现，**A数组每行miss 2次，一次冷不命中，一次与B数组冲突未命中**，而B数组除了**遍历第一行B数组8个全部miss**，之后**每行由于与A数组前一行以及当前行的冲突产生2次miss**，除了第1行和第8行

注意**缓存组冲突只出现在对角线位置处，对角线位置元素只有32个**
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-14-00-32.png)

因此**对角线位置的子矩阵**发生miss的情况：
* 每8个元素，A数组和B数组分别会产生1次冷不命中 (2×8)
* 每次缓存组冲突会使得A数组多产生1次miss，B数组多产生2次miss (3×8)
* **特别的，第1行和第8行的缓存组冲突只使B数组多产生1次miss(因为B数组的冲突未命中每次来自于上一行和本行，对于第1行，B数组的冷不命中和冲突未命中重叠了，对于第8行，产生1次冲突未命中后就结束了，没有第9行了)，第8行A数组只产生一次冷命中，不产生冲突未命中(这个原因和前面说过的一样，处于一个缓存组末尾的情况)** (-1-1-1=-3)

2×8+3×8-3=**37次**

对于**非对角线位置的子矩阵**发生miss的情况：
* 每8个元素，A数组和B数组分别产生1次冷不命中

8×2=**16次**

* 共 37×4(对角线子矩阵4个) + 16×12(非对角线子矩阵12个) = **340次**
* 或者 (1024/8)×2(冷未命中数) + 32×(1+2) - 3×4 (冲突未命中数)= 256 + 96 - 12 = **340次**

对应测试结果：`func 0 (Transpose submission): hits:1709, misses:344, evictions:312` (多出的4个前面说过了，是开头的3个和末尾的1个与循环无关的指令产生的miss)

> 这里计算这种情况的miss数真是给我整麻了，小细节太多了，特别是冲突未命中的情况，这里耗了我两三个小时，裂开。。。

分析得这么详细了，可以看到，除了**256次冷未命中无法避免**，**就只剩下多出的84次冲突未命中了**，如何将这些冲突未命中给消除掉呢？

我们已经知道冲突未命中是对角线位置数组A和数组B对同一个下标的元素进行load或store导致缓存刷新，产生冲突而造成的，而且这个冲突产生的本质是因为**数组A和数组B交错操作元素**，即**数组A load对角线元素后，紧接着数组B store对角线元素，再紧接着数组A又load对角线元素的后一个元素**，对于这种情况我们比较好处理，**可以一次性将数组A的8个元素先全部读入临时变量，再统一给数组B赋值**，这种情况共2×32-2×4=**56次miss**(每个对角线子矩阵的第1行数组B不产生此种冲突未命中，第8行数组A不产生此种冲突未命中)

但**除此之外，在遍历下一行时，数组B再使用到上一行对应的缓存组时，还是会由于数组A刚才的使用而产生1次冲突未命中**，这种情况共32×1-1×4=**28次miss**(每个对角线子矩阵的第8行数组B不产生此种冲突未命中)

我们先把第一种冲突未命中消除掉：
```cpp
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, k, l;

    for (i = 0; i < N; i += 8)
    {
        for (j = 0; j < M; j += 8)
        {
            for (k = i; k < i + 8; k++)
            {
                int temp[8];
                for (l = j; l < j + 8; l++)
                {
                    temp[l - j] = A[k][l];
                }
                for (l = j; l < j + 8; l++)
                {
                    B[l][k] = temp[l - j];
                }
            }
        }
    }
}
```

消除之后现在的未命中数应当为 340-56=**284次**

测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./test-trans -M 32 -N 32

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1765, misses:290, evictions:258

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152

Summary for official submission (func 0): correctness=1 misses=290

TEST_TRANS_RESULTS=1:290
```

还多出的6次miss也是开头和结尾与循环无关的指令产生的
开头4次：
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-15-10-53.png)
结尾2次：
![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-15-11-39.png)

如何消除最后剩下的28次冲突未命中呢

由于这些miss是由于数组B需要反复访问每一行，而数组A在其间访问了同一行所引起的，而他们又必须将整个矩阵每个元素都遍历到

因此我对这个问题的抽象是这个样子的：两个指针遍历这个8×8的矩阵，一个指针访问过的行，在这个指针把这一行全部访问完前，另一个指针不能碰，就像给行上了锁，这两个指针的遍历行为沿对角线对称，**在只能用到8个临时变量的条件下**，如何让它们把整个矩阵都遍历完

完全没思路。。还是看看知乎吧

还是自己的思路偏了。。不应该把问题聚焦在如何遍历，而是需要利用到空闲的空间

原来是利用到了数组B访问一行后，剩下的格子数组B要很久才会访问到，在其访问到剩余的格子之前，这些格子都可以用来临时存储其他值，既然知道了这个思路，就好做了

这样就可以在用临时变量将数组A的第1行存起来之后，将它们都先依次存到数组B的第1行中，然后再用临时变量将数组A的第2行存起来，然后将数组B第一行的第2个数存到第二行的第1个位置，将第1个临时变量(数组A的第二行第1个数)存到数组B第一行的第2个位置，即**沿对角线对称交换**，剩下的临时变量全部依次存到数组B的第二行，依次类推

**代码**(由于只有对角线子矩阵会出现冲突未命中，因此这次直接对非角线子矩阵和对角线子矩阵做了区分)：
```cpp
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, k, l;
    int temp[8];
    for (i = 0; i < N; i += 8)
    {
        for (j = 0; j < M; j += 8)
        {
            for (k = i; k < i + 8; k++) // 子矩阵的8行
            {
                if (i != j) // 非对角线子矩阵
                {
                    for (l = j; l < j + 8; l++) // 子矩阵的8列
                        B[l][k] = A[k][l];
                }
                else // i==j，对角线子矩阵
                {
                    for (l = j; l < j + 8; l++) // 子矩阵的8列
                        temp[l - j] = A[k][l];  // 取数组A的第k行暂存
                    for (l = j; l < j + 8; l++)
                    {
                        if (l < j + (k - i)) // 对数组B的第k行前k-i个元素以及它们的转置位置的元素进行赋值
                        {
                            B[k][l] = B[l][k];
                            B[l][k] = temp[l - j];
                        }
                        else
                            B[k][l] = temp[l - j];
                    }
                }
            }
        }
    }
}
```

测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./test-trans -M 32 -N 32

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:2081, misses:262, evictions:230

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152

Summary for official submission (func 0): correctness=1 misses=262

TEST_TRANS_RESULTS=1:262
```

减去临时变量导致的开头和结尾非循环指令中出现的6个miss，达到了理想最佳情况，miss数=256

#### 64×64

对于64×64的矩阵，做8×8的分块，可以分出64个子矩阵，32×32矩阵的代码可以直接用吗？

先运行下试试

```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./test-trans -M 64 -N 64

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
列
Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:3473, misses:4724, evictions:4692

Summary for official submission (func 0): correctness=1 misses=4382

TEST_TRANS_RESULTS=1:4382
```
。。。优化效果微小得可怜，为啥

32×32矩阵和64×64矩阵缓存组的对应情况对比：

![](./assets/5.%20lab5-Cache%20Lab/2023-08-16-16-53-58.png)

可以看到，64×64矩阵由于一行元素的个数是32×32矩阵的两倍，同一列中每隔4行对应的缓存组就循环一次，而32×32矩阵是每隔8行

而每隔4行，元素地址相差1024字节，这就会造成进行转置时为B数组每次赋值8个元素时，后4个元素与前4个元素缓存组冲突，导致B数组不断冲突未命中

A数组和B数组的冷不命中次数：64×64/8*2=1024次

现在来计算B的冲突未命中次数

首先再观察一下我们循环的赋值方式，对于对角线子矩阵，每次遍历A的一行，用临时变量存储，然后遍历B的对应行，在对角线之前的位置要和其转置后对应的位置进行交换，其余的直接存到B的对应行，这一步在行之间的缓存组不冲突时不会产生负担，而在前4行和后4行的缓存组冲突时，在遍历前4行时也不会产生冲突，而在遍历后4行时，则会由于冲突导致冲突未命中

下图中颜色相同的即为每次遍历一行时要交换的位置，而用彩色方框框起来的是不发生冲突的区域：
![](./assets/5.%20lab5-Cache%20Lab/2023-08-19-10-28-46.png)

冲突的情况：
1. **第i行第i%4个元素与第i列第i%4个元素交换时，发生4次冲突**
2. 除了第一种情况，每次赋值时由于列是4个为一个周期，**对列中单个元素赋值时也会和前面列的缓存组以及下一行的缓存组产生冲突**，这种冲突miss每次单个单个出现

**对角线子矩阵中的冲突miss次数**：4-1(遍历第5行时的冲突miss次数，和冷不命中重叠了1次) + 1+4+1(遍历第6行时的冲突miss次数) + 1+1+4+1+1(遍历第7行时的冲突miss次数) + 1+1+1+4+1+1+1(遍历第8行时的冲突miss次数)=3+6+8+10=**27次**

共 27×8=**216次**

对于非对角线子矩阵，我们是直接对转置位置赋值的，由于每前4行和后4行缓存组冲突，会导致对数组B的访问全部miss

**非对角线子矩阵中的冲突miss次数**：8×8-8(冷不命中次数)=**56次**

共56×(64-8)=**3136次**

全部总共：1024(冷不命中)+216(对角线子矩阵)+3136(非对角线子矩阵)=**4376次**

`func 0 (Transpose submission): hits:4393, misses:4382, evictions:4350`

减去临时变量导致的开头和结尾非循环指令中出现的6个miss，和测试结果相匹配

因此这里主要要消除的就是列中的缓存组冲突

如果将8×8换成4×4的话，可以减少很多miss次数，但是会由于这种分块方案产生更多的不可避免的冲突miss

其他什么都不变，只把代码中的8改成4，测试结果：
```shell
func 0 (Transpose submission): hits:6641, misses:1750, evictions:1718
```

因此想要完全消除冲突miss，我们还需要对8×8分块下子矩阵的赋值方式进行进一步优化

其实把非对角线子矩阵的赋值方式改成对角线矩阵的赋值方式就已经可以消除掉很多miss次数了，但是对角线矩阵发生冲突的方式十分复杂，不知道要怎么优化

可以对非对角线矩阵和对角线矩阵分别进行优化

看了一下知乎上大佬的文章(https://zhuanlan.zhihu.com/p/387662272)，先把非对角线矩阵的赋值优化一下

核心思路就是**将8×8的矩阵分成4个4×4的子矩阵分别进行赋值**，但是对原矩阵**按行遍历**，其中目标矩阵的**左上和右下矩阵直接转置赋值**，**右上矩阵暂存左下矩阵的转置值**，在**遍历后4行时再通过临时变量统一完成右上矩阵和左下矩阵的按行赋值**

```cpp
if (i != j) // 非对角线子矩阵
{
    for (k = i; k < i + 4; k++) // 前4行
    {
        for (l = j; l < j + 4; l++) // 前4行前4列，直接转置位置赋值
            B[l][k] = A[k][l];
        for (l = j + 4; l < j + 8; l++) // 前4行后4列，暂存在子矩阵右上方
            B[l - 4][k + 4] = A[k][l];
    }
    for (k = i + 4; k < i + 8; k++) // 后4行
    {
        for (l = j; l < j + 4; l++) // 先把右上角暂存的一列4个值取出来
            temp[l - j] = B[l][k];
        for (l = j; l < j + 4; l++) // 后4行前4列，给右上角转置位置赋值
            B[l][k] = A[k][l];
        for (l = j; l < j + 4; l++) // 再给左下角当前行前4个赋值
            B[l + 4][k - 4] = temp[l - j];
        for (l = j + 4; l < j + 8; l++) // 最后给右下角一行4个赋值
            B[l][k] = A[k][l];
    }
}
```

测试结果：
```shell
func 0 (Transpose submission): hits:7849, misses:2590, evictions:2558
```

怎么回事。。miss次数减少的数量好像不太对劲，检查一下发现，是遍历方式出了问题，这里一定要把行和列的对应关系还有赋值顺序理清楚
```cpp
if (i != j) // 非对角线子矩阵
{
    for (k = i; k < i + 4; k++) // 前4行
    {
        for (l = j; l < j + 4; l++) // 前4行前4列，直接转置位置赋值
            B[l][k] = A[k][l];
        for (l = j + 4; l < j + 8; l++) // 前4行后4列，暂存在子矩阵右上方
            B[l - 4][k + 4] = A[k][l];
    }
    for (l = j; l < j + 4; l++) // 后4行，按列遍历，先遍历前4列
    {
        for (k = i + 4; k < i + 8; k++) // 先把右上角暂存的一行4个值取出来
            temp[k - i - 4] = B[l][k];
        for (k = i + 4; k < i + 8; k++) // 后4行前4列，给右上角转置位置的对应行赋值
            B[l][k] = A[k][l];
        for (k = i + 4; k < i + 8; k++) // 再给左下角当前行前4个赋值
            B[l + 4][k - 4] = temp[k - i - 4];
    }
    for (l = j + 4; l < j + 8; l++)
        for (k = i + 4; k < i + 8; k++) // 后4行后4列
            B[l][k] = A[k][l];
}
```
测试结果：
```shell
func 0 (Transpose submission): hits:9193, misses:1246, evictions:1214
```

1024(冷不命中数)+216(对角线子矩阵冲突不命中数)=1240次

这样就只剩下冷不命中和对角线子矩阵中的冲突miss了

如何优化对角线子矩阵呢

对角线子矩阵存在的两种冲突miss：
1. 数组A和数组B相同行映射到相同缓存组
    * 通过一次性移动数组A的一行来避免冲突
2. 数组A、B的前4行和后4行都映射到相同缓存组
    * 不仅一次性移动数组A的一行，同时每次只对4×4的子矩阵进行操作

如果使用和非对角线子矩阵相同的思路，对4个4×4子矩阵分别操作，由于1. 的限制，会没有办法避免A和B相同行的缓存组冲突，因此我们只能首先一次复制一行

**在复制完整个前4行后，对于左上角和右上角的4×4子矩阵，可以对B数组进行原地的转置，这样就达到了和非对角线子矩阵相同的效果**

而**对于后4行**，此前的思路是先将右上角矩阵的一行暂存，然后给右上角矩阵赋值完后，再给左下角矩阵赋值，然而对于对角线矩阵，**数组A的第5、6、7、8行和数组B的1、2、3、4行也是缓存组冲突的**，**导致没有办法同时对它们进行交替操作**，既然是**A数组的行与B数组的行冲突了**，我们**就先把A数组的子矩阵暂存到B数组的其他非对角线子矩阵中**，**避免掉这种缓存组冲突**，然后**再按照和非对角线子矩阵相同的思路**进行赋值就可以了，而被作为暂存区域的子矩阵只会产生冷不命中，且在被借用后，再对它们进行操作时，就不会再产生冷不命中了，抵消掉了

不过要注意，这样遍历子矩阵的顺序也需要修改一下了，因为最后一个对角线子矩阵是所有子矩阵中的最后一个，如果按顺序遍历的话到最后会没有可以借用的非对角线子矩阵区域

我们可以直接在外循环中循环i时就直接对对角线子矩阵先进行处理，即遍历每行时先进行对角线子矩阵的处理，然后再顺序遍历当前行的其他子矩阵

对数组A是按行遍历，则对于数组B就是按列遍历，而每一列上的子矩阵对应的缓存组都是相同的，这样遍历的话到最后一个对角线子矩阵时能借用的子矩阵只剩下其上方的子矩阵了，这样仍会导致缓存组冲突，因此我们应该改变遍历顺序，对数组A按列遍历，这样对于数组B就是按行遍历了，每个对角线子矩阵直接借用该行中的任意一个子矩阵就可以了，这里我选取对角线子矩阵左边相邻的子矩阵暂存(第一个对角线子矩阵选取右边相邻的)

```cpp
i = j; // i==j，对角线子矩阵

for (k = i + 4; k < i + 8; k++) // 先把矩阵的后4行转移位置
{
   // 按行暂存到数组B相邻子矩阵的对应行
   for (l = j; l < j + 8; l++)
       if (j == 0) // 第一行第一个对角线子矩阵
           B[k][l + 8] = A[k][l];
       else // 其他对角线子矩阵
           B[k][l - 8] = A[k][l];
}
for (k = i; k < i + 4; k++) // 矩阵的前4行按行暂存到数组B的对应行
{
   for (l = j; l < j + 8; l++)
       temp[l - j] = A[k][l];
   for (l = j; l < j + 8; l++)
       B[k][l] = temp[l - j];
}
for (k = i; k < i + 4; k++) // 对B数组上方的两个子矩阵进行转置，注意这里循环只能循环一半元素，否则每个位置会交换两次
{
   for (l = j; l < j + k - i; l++) // 对左上角子矩阵进行转置处理
   {
       temp[0] = B[k][l];
       B[k][l] = B[l][k];
       B[l][k] = temp[0];
   }
   for (l = j + 4; l < j + 4 + k - i; l++) // 对右上角子矩阵进行转置处理
   {
       // k=i，l=j+4 => l-j-4+i，k-i+j+4
       temp[0] = B[k][l];
       B[k][l] = B[l - j - 4 + i][k - i + j + 4];
       B[l - j - 4 + i][k - i + j + 4] = temp[0];
   }
}
// 然后套用非对角线子矩阵的逻辑就可以了
for (l = j; l < j + 4; l++) // 后4行，按列遍历，先遍历前4列
{
   for (k = i + 4; k < i + 8; k++) // 先把右上角暂存的一行4个值取出来
       temp[k - i - 4] = B[l][k];
   for (k = i + 4; k < i + 8; k++) // 后4行前4列，给右上角转置位置的对应行赋值
       if (j == 0)                 // 第一行第一个对角线子矩阵
           B[l][k] = B[k][l + 8];
       else // 其他对角线子矩阵
           B[l][k] = B[k][l - 8];
   for (k = i + 4; k < i + 8; k++) // 再给左下角当前行前4个赋值
       B[l + 4][k - 4] = temp[k - i - 4];
}
for (l = j + 4; l < j + 8; l++)
   for (k = i + 4; k < i + 8; k++) // 后4行后4列
       if (j == 0)
           B[l][k] = B[k][l + 8];
       else
           B[l][k] = B[k][l - 8];
```

测试结果：
```shell
func 0 (Transpose submission): hits:10081, misses:1062, evictions:1030
```

。。。1062是什么鬼，比1024+6=1030多个32个miss，这是为啥

哦，原来是我在借用B矩阵中非对角线矩阵的区域时，借用的是后4行，但是遍历到这些矩阵的时候，会首先遍历它们的前4行，这样就还是产生了冲突，因此在借用它们的空间时，必须借用前4行，即x坐标减4，就可以了

```cpp
i = j; // i==j，对角线子矩阵

for (k = i + 4; k < i + 8; k++) // 先把矩阵的后4行转移位置
{
   // 按行暂存到数组B相邻子矩阵的对应行
   for (l = j; l < j + 8; l++)
       if (j == 0) // 第一行第一个对角线子矩阵
           B[k - 4][l + 8] = A[k][l];
       else // 其他对角线子矩阵
           B[k - 4][l - 8] = A[k][l];
}
for (k = i; k < i + 4; k++) // 矩阵的前4行按行暂存到数组B的对应行
{
   for (l = j; l < j + 8; l++)
       temp[l - j] = A[k][l];
   for (l = j; l < j + 8; l++)
       B[k][l] = temp[l - j];
}
for (k = i; k < i + 4; k++) // 对B数组上方的两个子矩阵进行转置，注意这里循环只能循环一半元素，否则每个位置会交换两次
{
   for (l = j; l < j + k - i; l++) // 对左上角子矩阵进行转置处理
   {
       temp[0] = B[k][l];
       B[k][l] = B[l][k];
       B[l][k] = temp[0];
   }
   for (l = j + 4; l < j + 4 + k - i; l++) // 对右上角子矩阵进行转置处理
   {
       // k=i，l=j+4 => l-j-4+i，k-i+j+4
       temp[0] = B[k][l];
       B[k][l] = B[l - j - 4 + i][k - i + j + 4];
       B[l - j - 4 + i][k - i + j + 4] = temp[0];
   }
}
// 然后套用非对角线子矩阵的逻辑就可以了
for (l = j; l < j + 4; l++) // 后4行，按列遍历，先遍历前4列
{
   for (k = i + 4; k < i + 8; k++) // 先把右上角暂存的一行4个值取出来
       temp[k - i - 4] = B[l][k];
   for (k = i + 4; k < i + 8; k++) // 后4行前4列，给右上角转置位置的对应行赋值
       if (j == 0)                 // 第一行第一个对角线子矩阵
           B[l][k] = B[k - 4][l + 8];
       else // 其他对角线子矩阵
           B[l][k] = B[k - 4][l - 8];
   for (k = i + 4; k < i + 8; k++) // 再给左下角当前行前4个赋值
       B[l + 4][k - 4] = temp[k - i - 4];
}
for (l = j + 4; l < j + 8; l++)
   for (k = i + 4; k < i + 8; k++) // 后4行后4列
       if (j == 0)
           B[l][k] = B[k - 4][l + 8];
       else
           B[l][k] = B[k - 4][l - 8];
```

完整代码：
```cpp
void transpose_64_plus_64(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, k, l;
    int temp[8];
    for (j = 0; j < M; j += 8)
    {
        i = j; // i==j，对角线子矩阵

        for (k = i + 4; k < i + 8; k++) // 先把矩阵的后4行转移位置
        {
            // 按行暂存到数组B相邻子矩阵的对应行
            for (l = j; l < j + 8; l++)
                if (j == 0) // 第一行第一个对角线子矩阵
                    B[k - 4][l + 8] = A[k][l];
                else // 其他对角线子矩阵
                    B[k - 4][l - 8] = A[k][l];
        }
        for (k = i; k < i + 4; k++) // 矩阵的前4行按行暂存到数组B的对应行
        {
            for (l = j; l < j + 8; l++)
                temp[l - j] = A[k][l];
            for (l = j; l < j + 8; l++)
                B[k][l] = temp[l - j];
        }
        for (k = i; k < i + 4; k++) // 对B数组上方的两个子矩阵进行转置，注意这里循环只能循环一半元素，否则每个位置会交换两次
        {
            for (l = j; l < j + k - i; l++) // 对左上角子矩阵进行转置处理
            {
                temp[0] = B[k][l];
                B[k][l] = B[l][k];
                B[l][k] = temp[0];
            }
            for (l = j + 4; l < j + 4 + k - i; l++) // 对右上角子矩阵进行转置处理
            {
                // k=i，l=j+4 => l-j-4+i，k-i+j+4
                temp[0] = B[k][l];
                B[k][l] = B[l - j - 4 + i][k - i + j + 4];
                B[l - j - 4 + i][k - i + j + 4] = temp[0];
            }
        }
        // 然后套用非对角线子矩阵的逻辑就可以了
        for (l = j; l < j + 4; l++) // 后4行，按列遍历，先遍历前4列
        {
            for (k = i + 4; k < i + 8; k++) // 先把右上角暂存的一行4个值取出来
                temp[k - i - 4] = B[l][k];
            for (k = i + 4; k < i + 8; k++) // 后4行前4列，给右上角转置位置的对应行赋值
                if (j == 0)                 // 第一行第一个对角线子矩阵
                    B[l][k] = B[k - 4][l + 8];
                else // 其他对角线子矩阵
                    B[l][k] = B[k - 4][l - 8];
            for (k = i + 4; k < i + 8; k++) // 再给左下角当前行前4个赋值
                B[l + 4][k - 4] = temp[k - i - 4];
        }
        for (l = j + 4; l < j + 8; l++)
            for (k = i + 4; k < i + 8; k++) // 后4行后4列
                if (j == 0)
                    B[l][k] = B[k - 4][l + 8];
                else
                    B[l][k] = B[k - 4][l - 8];

        for (i = 0; i < N; i += 8)
        {
            if (i != j) // 非对角线子矩阵
            {
                for (k = i; k < i + 4; k++) // 前4行
                {
                    for (l = j; l < j + 4; l++) // 前4行前4列，直接转置位置赋值
                        B[l][k] = A[k][l];
                    for (l = j + 4; l < j + 8; l++) // 前4行后4列，暂存在子矩阵右上方
                        B[l - 4][k + 4] = A[k][l];
                }
                for (l = j; l < j + 4; l++) // 后4行，按列遍历，先遍历前4列
                {
                    for (k = i + 4; k < i + 8; k++) // 先把右上角暂存的一行4个值取出来
                        temp[k - i - 4] = B[l][k];
                    for (k = i + 4; k < i + 8; k++) // 后4行前4列，给右上角转置位置的对应行赋值
                        B[l][k] = A[k][l];
                    for (k = i + 4; k < i + 8; k++) // 再给左下角当前行前4个赋值
                        B[l + 4][k - 4] = temp[k - i - 4];
                }
                for (l = j + 4; l < j + 8; l++)
                    for (k = i + 4; k < i + 8; k++) // 后4行后4列
                        B[l][k] = A[k][l];
            }
        }
    }
}
```

测试结果：
```shell
func 0 (Transpose submission): hits:10113, misses:1030, evictions:998
```

达到了最优解1024

#### 61×67

61×67的矩阵和前两种矩阵都不一样了，变成了不规则的矩阵，用前两问的代码运行会直接出错

而且61和67都是质数，矩阵分块也不好实现了

61×67=4087并不能被8整除，只能确定的是从头开始每8个元素一个缓存组，每8×32=256个元素缓存组循环一次

朴素实现的miss数：
```shell
func 1 (Simple row-wise scan transpose): hits:3755, misses:4424, evictions:4392
```

我们先每次按8个一组操作优化一下试试

```cpp
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, k;
    int temp[8];
    i = 0, j = 0;
    while (1)
    {
        for (k = 0; k < 8; k++)
        {
            if (i == N)
                break;
            temp[k] = A[i][j];
            j++;
            if (j == M)
                j = 0, i++;
        }
        for (k--; k >= 0; k--)
        {
            j--;
            if (j == -1)
                j = M - 1, i--;
            B[j][i] = temp[k];
        }
        j += 8;
        if (j >= M)
        {
            i++;
            j %= M;
        }
        if (i == N)
            return;
    }
}
```

```shell
func 0 (Transpose submission): hits:3871, misses:4310, evictions:4278
```

好像还是得分块，8×8分块：

```cpp
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, k, l;
    for (i = 0; i < N; i += 8)
    {
        for (j = 0; j < M; j += 8)
        {
            for (k = i; k < (i + 8 >= N ? N : i + 8); k++)     // 子矩阵的8行
                for (l = j; l < (j + 8 >= M ? M : j + 8); l++) // 子矩阵的8列
                    B[l][k] = A[k][l];
        }
    }
}
```
测试结果：
```shell
func 0 (Transpose submission): hits:6060, misses:2119, evictions:2087
```

4×4分块结果：
```shell
func 0 (Transpose submission): hits:5753, misses:2426, evictions:2394
```

12×12分块结果：
```shell
func 0 (Transpose submission): hits:6121, misses:2058, evictions:2026
```

16×16分块结果：
```shell
func 0 (Transpose submission): hits:6186, misses:1993, evictions:1961
```

20×20分块结果：
```shell
func 0 (Transpose submission): hits:6176, misses:2003, evictions:1971
```

24×24分块结果：
```shell
func 0 (Transpose submission): hits:6163, misses:2016, evictions:1984
```

那就16×16吧
```cpp
char transpose_submit_desc[] = "Transpose submission";
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
    int i, j, k, l;
    int temp = 16;
    for (i = 0; i < N; i += temp)
    {
        for (j = 0; j < M; j += temp)
        {
            for (k = i; k < (i + temp >= N ? N : i + temp); k++)     // 子矩阵的8行
                for (l = j; l < (j + temp >= M ? M : j + temp); l++) // 子矩阵的8列
                    B[l][k] = A[k][l];
        }
    }
}
```

```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./test-trans -M 61 -N 67

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:6186, misses:1993, evictions:1961

Function 1 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 1 (Simple row-wise scan transpose): hits:3755, misses:4424, evictions:4392

Summary for official submission (func 0): correctness=1 misses=1993

TEST_TRANS_RESULTS=1:1993
```

全部测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/cachelab# ./driver.py
Part A: Testing cache simulator
Running ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27


Part B: Testing transpose function
Running ./test-trans -M 32 -N 32
Running ./test-trans -M 64 -N 64
Running ./test-trans -M 61 -N 67

Cache Lab summary:
                        Points   Max pts      Misses
Csim correctness          27.0        27
Trans perf 32x32           8.0         8         262
Trans perf 64x64           8.0         8        1030
Trans perf 61x67          10.0        10        1995
          Total points    53.0        53
```

终于把这个lab搞定了
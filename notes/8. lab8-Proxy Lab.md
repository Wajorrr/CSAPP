# 前置知识

## 系统级I/O

### 无缓冲区rio_readn

不额外使用缓冲区，**每次调用rio_readn都进行read系统调用**，只是**在原来read的基础上增加了当read系统调用被一个信号处理程序中断时的处理逻辑**。
```c
/*
 * rio_readn - Robustly read n bytes (unbuffered)
 * 健壮地读入 n 个字节，无缓冲区
 * 即直接从系统调用read读取数据，而不是先读取到某个缓冲区，然后再从缓冲区读取到usrbuf
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n)
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0)
    {
        if ((nread = read(fd, bufp, nleft)) < 0)
        {
            // 如果一个系统调用（如read）被一个信号处理程序中断
            // 那么系统调用可能会提前返回，错误号errno被设置为EINTR
            // 这是一种常见的处理信号中断系统调用的方法，称为重启动系统调用。
            //  若由于信号处理程序返回而中断，则再次调用 read()，否则读取失败，返回-1
            if (errno == EINTR) /* Interrupted by sig handler return */
                nread = 0;      /* and call read() again */
            else
                return -1; /* errno set by read() */
        }
        else if (nread == 0) // 读取到文件末尾
            break;           /* EOF */
        nleft -= nread;
        bufp += nread;
    }
    return (n - nleft); /* Return >= 0 */
}
/* $end rio_readn */
```

### 有缓冲区rio_readnb、rio_readlineb

#### 缓冲区结构体rio_t
```c
/* Persistent state for the robust I/O (Rio) package */
/* $begin rio_t */
#define RIO_BUFSIZE 8192
typedef struct // 自定义的带缓冲区的读入结构体
{
    int rio_fd; /* Descriptor for this internal buf */       // 描述符
    int rio_cnt; /* Unread bytes in internal buf */          // 缓冲区中未读字节数
    char *rio_bufptr; /* Next unread byte in internal buf */ // 下一个未读字节
    char rio_buf[RIO_BUFSIZE]; /* Internal buffer */         // 缓冲区
} rio_t;
/* $end rio_t */
```

#### 带缓冲区rio_read
相较于不带缓冲区的rio_read，这里**每次固定读取缓冲区大小数量的字节**，**而不是指定的n个字节**，这样当n的大小小于缓冲区大小时，**进行多次读取可以在执行一次read系统调用后，之后多次直接从缓冲区中读取**，**减少了系统调用的次数，即陷入内核的次数**，提高了效率
```c
/*
 * rio_read - This is a wrapper for the Unix read() function that
 *    transfers min(n, rio_cnt) bytes from an internal buffer to a user
 *    buffer, where n is the number of bytes requested by the user and
 *    rio_cnt is the number of unread bytes in the internal buffer. On
 *    entry, rio_read() refills the internal buffer via a call to
 *    read() if the internal buffer is empty.
 */
/* $begin rio_read */
// 添加缓冲区的rio_read，使用缓冲区之后一次read可以对应多次rio_read的调用
// 减少read的调用次数，提高效率
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;
    while (rp->rio_cnt <= 0) // 当内部缓冲区为空（即rio_cnt小于等于0）时
    {                        /* Refill if buf is empty */
        rp->rio_cnt = read(rp->rio_fd, rp->rio_buf,
                           sizeof(rp->rio_buf)); // 默认把缓冲区读满
        if (rp->rio_cnt < 0)
        {
            // 若错误号errno不为EINTR，则读取错误，返回-1，否则重新循环读取
            if (errno != EINTR) /* Interrupted by sig handler return */
                return -1;
        }
        else if (rp->rio_cnt == 0) /* EOF */
            return 0;
        else                              // 更新内部缓冲区指针rio_bufptr
            rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */
    }

    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
    cnt = n;
    if (rp->rio_cnt < n)
        cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    // 更新内部缓冲区指针rio_bufptr和未读字节数rio_cnt
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
/* $end rio_read */
```

#### rio_readnb

调用rio_read来读取n个字节
```c
/*
 * rio_readnb - Robustly read n bytes (buffered)
 */
/* $begin rio_readnb */
// 调用rio_read来读取n个字节
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) // 若n大于缓冲区的大小，则需要多次读取，直到读取n个字节
    {
        if ((nread = rio_read(rp, bufp, nleft)) < 0)
            return -1; /* errno set by read() */
        else if (nread == 0)
            break;      /* EOF */
        nleft -= nread; // 剩余需要读取的字节
        bufp += nread;  // 更新读取的位置
    }
    return (n - nleft); /* return >= 0 */ // 返回读取的字节数
}
/* $end rio_readnb */
```

#### rio_readlineb

调用rio_read来读取一行
```c
/*
 * rio_readlineb - Robustly read a text line (buffered)
 */
/* $begin rio_readlineb */
// 调用rio_read，读取一行
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)
{
    int n, rc;
    char c, *bufp = usrbuf;

    for (n = 1; n < maxlen; n++) // 一个字符一个字符读取
    {
        if ((rc = rio_read(rp, &c, 1)) == 1)
        {
            *bufp++ = c;
            if (c == '\n') // 读取到换行则退出循环
            {
                n++;
                break;
            }
        }
        else if (rc == 0) // 读取到文件末尾
        {
            if (n == 1)
                return 0; /* EOF, no data read */
            else
                break; /* EOF, some data was read */
        }
        else           // 读取错误
            return -1; /* Error */
    }
    *bufp = 0;
    return n - 1; // 返回读取的字节数
}
/* $end rio_readlineb */
```

### 无缓冲区rio_writen

和无缓冲区的rio_readn一样，也是添加了被信号处理程序打断时的处理逻辑，且write涉及到对描述符文件的修改，没办法通过添加缓冲区来减少开销

```c
/*
 * rio_writen - Robustly write n bytes (unbuffered)
 */
/* $begin rio_writen */
// 文件描述符为fd，写入usrbuf指向的数据，长度为n
ssize_t rio_writen(int fd, void *usrbuf, size_t n)
{
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) // 循环直到写完n个字节的数据
    {
        // 向fd写入usrbuf的数据，长度为n，返回写入的数据长度nwritten
        if ((nwritten = write(fd, bufp, nleft)) <= 0)
        {
            if (errno == EINTR) /* Interrupted by sig handler return */
                nwritten = 0;   /* and call write() again */
            else
                return -1; /* errno set by write() */
        }
        nleft -= nwritten;
        bufp += nwritten;
    }
    return n;
}
/* $end rio_writen */
```

## socket连接
### 基于socket的网络应用概述

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-15-14-46.png)

### sockaddr套接字地址结构

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-15-18-20.png)

> _in后缀是互联网络(internet)的缩写，而不是输入(input)的缩写。

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-15-21-30.png)

### socket函数：创建套接字

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-15-23-46.png)

### connect函数：客户端建立向服务器请求建立连接

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-15-28-31.png)

### bind函数：服务器绑定套接字

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-15-30-33.png)

### listen函数：服务器等待客户端连接

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-15-58-58.png)

### accept函数：服务器接受客户端连接请求

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-16-06-15.png)


>来自：(https://zhuanlan.zhihu.com/p/680187157)
>
>关于 accept 函数，一个值得注意的点是，它其实仅仅是从已经建立连接的队列中取出一个连接（这基于并发编程中提到的 I/O 多路复用），而不是建立连接。建立连接的过程是在 listen 函数中完成的，这个过程是一个被动的过程，即服务端在 listen 函数中等待客户端的连接请求，而不是主动地去连接客户端。这一点和客户端是不同的，客户端是主动地去连接服务端的。而 listen 函数也有一个 LISTENQ 参数，用以规制最大的连接队列长度。
>
> 因而只要网络畅通，对于客户端来说，尽管 connect 函数是一个可能阻塞的函数，但是只要服务端已经调用了 listen 函数，那么 connect 函数就不会阻塞，而是会立刻返回。但服务端肯定要先使用 accept 函数取出一个连接才可以开始对应的处理（这就是有道往年题问使用顺序服务器客户端为什么阻塞在 read 而不是 connect 的原因），也是为什么我们需要并发编程而不是顺序编程的原因。

### 监听描述符与已连接描述符

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-16-08-53.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-16-10-39.png)

### getaddrinfo函数

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-16-57-13.png)

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-15-17-03-35.png)

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-18-13-46-10.png)

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-18-14-02-04.png)

### getnameinfo函数

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-18-14-07-46.png)

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-19-17-03-16.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-19-17-04-16.png)

```c
#include "csapp.h"

// 输入域名，返回其IP地址和端口号
int main(int argc, char **argv)
{
    struct addrinfo *p, *listp, hints;
    char buf[MAXLINE], service[MAXLINE];
    int rc, flags;

    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <domain name>\n", argv[0]);
        exit(0);
    }

    /* Get a list of addrinfo records */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET; /* ipv4 only */          // 将列表限制为 IPv4 地址
    hints.ai_socktype = SOCK_STREAM; /* Connect Only */ // 将列表限制为对每个地址最多一个 addrinfo 结构，该结构的套接字地址可以作为连接的一个端点
    hints.ai_flags = AI_NUMERICSERV;                    // 参数 service 默认可以是服务名或端口号。这个标志强制参数 service 为端口号 。

    if ((rc = getaddrinfo(argv[1], NULL, &hints, &listp)) != 0) // 将域名转换为套接字地址结构，即addrinfo构成的链表
    {
        fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(rc));
        exit(0);
    }
    /* Walk the list and display each IP address */
    // NI_NUMERICHOST：getnameinfo 默认试图返回host中的域名。设置该标志会使该函数返回一个数字地址字符串。
    flags = NI_NUMERICHOST;            /* Display address string instead of domain name */
    for (p = listp; p; p = p->ai_next) // 顺序读取链表中的每个ip地址
    {
        Getnameinfo(p->ai_addr, p->ai_addrlen, buf, MAXLINE, service, MAXLINE, flags); // 将一个套接字地址结构转换成相应的主机和服务名字符串

        printf("%s : %s\n", buf, service); // 打印host,service(ip:端口)
    }

    /* Clean up */
    Freeaddrinfo(listp);

    exit(0);
}
```


### 辅助函数
#### open_clientfd函数

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-19-16-02-29.png)

```c
/*
 * open_clientfd - Open connection to server at <hostname, port> and
 *     return a socket descriptor ready for reading and writing. This
 *     function is reentrant and protocol-independent.
 *
 *     On error, returns:
 *       -2 for getaddrinfo error
 *       -1 with errno set for other errors.
 */
/* $begin open_clientfd */
// 给定hostname+端口，客户端请求连接服务器，成功则返回一个套接字描述符，客户端可以开始与服务器通信
int open_clientfd(char *hostname, char *port)
{
    int clientfd, rc;
    struct addrinfo hints, *listp, *p;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM; /* Open a connection */
    hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */
    hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */

    // 将域名转换为套接字地址结构，即addrinfo构成的链表，成功则返回0，失败则返回非0的错误代码
    if ((rc = getaddrinfo(hostname, port, &hints, &listp)) != 0)
    {
        fprintf(stderr, "getaddrinfo failed (%s:%s): %s\n", hostname, port, gai_strerror(rc));
        return -2;
    }

    /* Walk the list for one that we can successfully connect to */
    for (p = listp; p; p = p->ai_next) // 遍历addrinfo链表
    {
        /* Create a socket descriptor */
        // 创建一个套接字描述符
        if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
            continue; /* Socket failed, try the next */

        /* Connect to the server */
        // 向当前addrinfo指向的服务器请求连接
        if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1)
            break; /* Success */ // 成功则直接退出循环

        // 当前addrinfo连接失败，关闭套接字描述符，继续尝试下一个addrinfo
        if (close(clientfd) < 0)
        { /* Connect failed, try another */ // line:netp:openclientfd:closefd

            fprintf(stderr, "open_clientfd: close failed: %s\n", strerror(errno)); // 关闭失败，报错
            return -1;
        }
    }

    /* Clean up */ // 释放addrinfo链表的空间
    freeaddrinfo(listp);
    if (!p) /* All connects failed */
        return -1;
    else /* connect succeeded */
        return clientfd;
}
/* $end open_clientfd */
```

#### open_listenfd函数

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-19-16-04-07.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-19-16-37-58.png)

最后，我们调用 listen 函数，将 listenfd 转换为一个监听描述符，并返回给调用者。如果 listen 失败，我们要小心地避免内存泄漏，在返回前关闭描述符。

```c
/*
 * open_listenfd - Open and return a listening socket on port. This
 *     function is reentrant and protocol-independent.
 *
 *     On error, returns:
 *       -2 for getaddrinfo error
 *       -1 with errno set for other errors.
 */
/* $begin open_listenfd */
// 传入端口，服务器打开和返回一个监听描述符，这个描述符准备好在端口port上接收连接请求
int open_listenfd(char *port)
{
    struct addrinfo hints, *listp, *p;
    int listenfd, rc, optval = 1;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;             /* Accept connections */
    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */
    hints.ai_flags |= AI_NUMERICSERV;            /* ... using port number */

    // 将域名转换为套接字地址结构，即addrinfo构成的链表，成功则返回0，失败则返回非0的错误代码
    if ((rc = getaddrinfo(NULL, port, &hints, &listp)) != 0)
    {
        fprintf(stderr, "getaddrinfo failed (port %s): %s\n", port, gai_strerror(rc));
        return -2;
    }

    /* Walk the list for one that we can bind to */
    for (p = listp; p; p = p->ai_next)
    {
        /* Create a socket descriptor */
        // 创建一个套接字描述符
        if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
            continue; /* Socket failed, try the next */

        /* Eliminates "Address already in use" error from bind */
        // setsockopt使得服务器能够被终止、重启和立即开始接收连接请求
        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, // line:netp:csapp:setsockopt
                   (const void *)&optval, sizeof(int));

        /* Bind the descriptor to the address */
        // 将addrinfo中的服务器套接字地址与套接字描述符联系起来
        if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
            break; /* Success */ // 绑定成功则退出

        if (close(listenfd) < 0) // 绑定失败，关闭套接字描述符
        {                        /* Bind failed, try the next */
            fprintf(stderr, "open_listenfd close failed: %s\n", strerror(errno));
            return -1;
        }
    }

    /* Clean up */
    freeaddrinfo(listp); // 释放addrinfo列表的空间
    if (!p)              /* No address worked */
        return -1;

    /* Make it a listening socket ready to accept connection requests */
    // 套接字描述符绑定成功，将套接字转化为一个监听套接字，开始接受来自客户端的连接请求
    if (listen(listenfd, LISTENQ) < 0)
    {
        close(listenfd); // 出错则关闭套接字描述符，然后返回-1
        return -1;
    }
    return listenfd; // 返回监听套接字描述符
}
/* $end open_listenfd */
```

## echo客户端和服务器示例

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-20-16-28-18.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-20-16-28-50.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-20-16-29-37.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-20-16-37-58.png)

客户端：
```c
#include "csapp.h"

// 给定服务器的域名/ip地址 以及服务器端口，连接服务器，从标准输入读取信息，发送到服务器，并将服务器回送的信息输出到标准输出
int main(int argc, char **argv)
{
    int clientfd;
    char *host, *port, buf[MAXLINE];
    rio_t rio; // rio_t类型为一个读缓冲区

    if (argc != 3)
    {
        fprintf(stderr, "usage: %s <host> <port>\n", argv[0]);
        exit(0);
    }

    host = argv[1]; // 服务器域名/ip地址
    port = argv[2]; // 服务器端口

    clientfd = Open_clientfd(host, port); // 请求连接服务器
    // rio_readinitb 函数创建了一个空的读缓冲区，并且将一个打开的文件描述符和这个缓冲区联系起来
    Rio_readinitb(&rio, clientfd);

    while (Fgets(buf, MAXLINE, stdin) != NULL) // 从stdin循环读取MAXLINE长度的数据
    {
        Rio_writen(clientfd, buf, strlen(buf)); // 将读取的数据发送给服务器
        rio_readlineb(&rio, buf, MAXLINE);      // 再从缓冲区中读出服务器回送写入到缓冲区的数据
        printf("received from server: %s", buf);
        // Fputs(buf, stdout);                     // 将从缓存区中读出的数据输出到stdout
    }
    close(clientfd);
    exit(0);
}
```

服务器：
```c
#include "csapp.h"

// 传入连接描述符
void echo(int connfd)
{
    size_t n;
    char buf[MAXLINE];
    rio_t rio; // 读缓冲区

    // rio_readinitb 函数创建了一个空的读缓冲区，并且将一个打开的文件描述符和这个缓冲区联系起来
    Rio_readinitb(&rio, connfd);
    while ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) // 循环从缓冲区中读取
    {
        printf("server received %d bytes, message: %s\n", (int)n, buf); // 从客户端接收到的字节数

        Rio_writen(connfd, buf, n); // 将接收到的客户端发来的数据再发送回客户端
    }
}

// 给定端口，在给定端口打开监听描述符
int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr; /* Enough space for any address */

    char client_hostname[MAXLINE], client_port[MAXLINE]; // 客户端的ip和端口

    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }

    listenfd = Open_listenfd(argv[1]); // 从给定端口打开监听描述符
    while (1)                          // 循环等待客户端连接
    {
        clientlen = sizeof(struct sockaddr_storage);
        // 接收到客户端的连接请求，返回非负连接描述符，并获取sockaddr和addrlen
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        // 将套接字地址结构sockaddr转换成相应的主机和服务名(端口)字符串
        Getnameinfo((SA *)&clientaddr, clientlen, client_hostname, MAXLINE, client_port, MAXLINE, 0);
        printf("Connected to (%s, %s) \n", client_hostname, client_port); // 输出当前连接的客户端ip和端口

        echo(connfd);  // 从连接描述符读取客户端发来的信息，并将相同的信息发送回去
        Close(connfd); // 当前连接结束，继续等待下一个客户端连接
    }
    exit(0);
}
```

运行示例：
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-20-16-34-19.png)

## Tiny Web服务器示例

除了这个tiny web服务器的实现之外，csapp书的前面也有很多web相关的内容，目前只是看了一遍，没花时间记笔记，之后有机会再回顾的时候去记一下笔记

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-24-10.png)

### 实现

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-57-11.png)

#### tiny web服务器的函数声明
```c
/*
 * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the
 *     GET method to serve static and dynamic content.
 *
 * Updated 11/2019 droh
 *   - Fixed sprintf() aliasing issue in serve_static(), and clienterror().
 */
#include "csapp.h"

void doit(int fd);
void read_requesthdrs(rio_t *rp);
int parse_uri(char *uri, char *filename, char *cgiargs);
void serve_static(int fd, char *filename, int filesize);
void get_filetype(char *filename, char *filetype);
void serve_dynamic(int fd, char *filename, char *cgiargs);
void clienterror(int fd, char *cause, char *errnum,
                 char *shortmsg, char *longmsg);
```

#### main函数：服务器打开socket，循环等待接受客户端连接

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-59-50.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-58-37.png)

```c
/* $begin tinymain */
// 传入参数为端口号，初始化web服务器，等待接收客户端连接请求
int main(int argc, char **argv)
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    /* Check command line args */
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(1);
    }

    listenfd = Open_listenfd(argv[1]); // 服务器根据端口号打开监听描述符
    while (1)
    { // 循环等待客户端连接
        clientlen = sizeof(clientaddr);
        // 接收客户端连接请求
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen); // line:netp:tiny:accept
        // 获取客户端的ip和端口
        Getnameinfo((SA *)&clientaddr, clientlen, hostname, MAXLINE,
                    port, MAXLINE, 0);
        printf("Accepted connection from (%s, %s)\n", hostname, port);
        // 根据连接描述符，调用doit函数处理一个HTTP事务
        doit(connfd);  // line:netp:tiny:doit
        Close(connfd); // line:netp:tiny:close
    }
}
/* $end tinymain */
```

#### doit函数：服务器响应客户端HTTP请求

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-00-18.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-58-58.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-59-13.png)

```c
/*
 * doit - handle one HTTP request/response transaction
 */
/* $begin doit */
// 传入参数为连接描述符
void doit(int fd)
{
    int is_static;
    struct stat sbuf;
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    char filename[MAXLINE], cgiargs[MAXLINE];
    rio_t rio;

    /* Read request line and headers */
    // 初始化读缓冲区，并与连接描述符绑定
    Rio_readinitb(&rio, fd);
    // 读取和解析请求行
    if (!Rio_readlineb(&rio, buf, MAXLINE)) // line:netp:doit:readrequest
        return;
    printf("%s", buf); // 打印读取的请求行

    // 从请求行中解析出请求方法、uri以及HTTP版本
    sscanf(buf, "%s %s %s", method, uri, version); // line:netp:doit:parserequest

    // 判断请求方法，这里只对GET方法进行处理
    if (strcasecmp(method, "GET"))
    { // line:netp:doit:beginrequesterr
        // 若不是GET方法，报错501
        clienterror(fd, method, "501", "Not Implemented",
                    "Tiny does not implement this method");
        return;
    } // line:netp:doit:endrequesterr
    // 读取请求报头，并忽略所有请求报头
    read_requesthdrs(&rio); // line:netp:doit:readrequesthdrs

    // 自此读取请求结束

    /* Parse URI from GET request */
    // 传入uri字符串，解析uri，解析后若为静态内容则返回1，若为动态内容则返回0
    is_static = parse_uri(uri, filename, cgiargs); // line:netp:doit:staticcheck

    // 调用stat函数获取文件信息，若执行失败，则返回文件不存在
    if (stat(filename, &sbuf) < 0)
    { // line:netp:doit:beginnotfound
        clienterror(fd, filename, "404", "Not found",
                    "Tiny couldn't find this file");
        return;
    } // line:netp:doit:endnotfound

    if (is_static) // 静态内容
    {              /* Serve static content */

        // 若请求的文件不是普通文件或不具有读权限，返回403
        if (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR & sbuf.st_mode))
        { // line:netp:doit:readable
            clienterror(fd, filename, "403", "Forbidden",
                        "Tiny couldn't read the file");
            return;
        }
        // 否则返回静态内容
        serve_static(fd, filename, sbuf.st_size); // line:netp:doit:servestatic
    }
    else // 动态内容
    {    /* Serve dynamic content */

        // 若请求的文件不是普通文件或不具有读权限，返回403
        if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR & sbuf.st_mode))
        { // line:netp:doit:executable
            clienterror(fd, filename, "403", "Forbidden",
                        "Tiny couldn't run the CGI program");
            return;
        }
        // 否则返回动态内容
        serve_dynamic(fd, filename, cgiargs); // line:netp:doit:servedynamic
    }
}
/* $end doit */
```

##### 补充：stat函数

stat函数是一个Unix系统调用，用于获取文件的状态信息
* stat函数接受两个参数：
  * 一个是想要获取信息的文件的路径
  * 另一个是一个struct stat类型的指针，stat函数会将文件的状态信息填充到这个结构体中。
* stat函数的返回值是一个整数。如果函数成功执行，返回值为0。如果函数执行失败，返回值为-1。
* 当stat函数执行失败时，可以通过检查全局变量errno来确定错误的原因。
  * 例如，如果errno的值为ENOENT，那么可能是因为指定的文件不存在。
* struct stat是一个结构体，用于存储文件或文件系统对象的信息，其在sys/stat.h头文件中定义，包含了很多字段，包括文件的大小、文件的所有者、文件的权限等等。下面是一些常见的字段：
    * `st_mode`：文件类型和模式（权限）。
    * `st_ino`：文件的inode号。
    * `st_dev`：包含文件的设备ID。
    * `st_rdev`：如果文件是特殊设备，这是其设备ID。
    * `st_nlink`：文件的硬链接数。
    * `st_uid`：文件所有者的用户ID。
    * `st_gid`：文件所有者的组ID。
    * `st_size`：文件的大小（字节）。
    * `st_atime`：文件最后访问的时间。
    * `st_mtime`：文件最后修改的时间。
    * `st_ctime`：文件状态最后更改的时间。
* 检查请求的文件是否是一个普通文件：`S_ISREG(sbuf.st_mode)`
    * 在Unix和类Unix系统中，文件系统中的每个对象都被视为文件。这些文件可以分为几种类型，其中包括：
        * **普通文件**（Regular Files）：这是最常见的文件类型，通常包含某种形式的数据。例如，一个文本文件或一个二进制可执行文件都是普通文件。
        * **目录**（Directories）：目录是包含其他文件（包括其他目录）的文件。
        * **符号链接**（Symbolic Links）：符号链接是一个特殊类型的文件，它是对另一个文件的引用。
        * **设备文件**（Device Files）：设备文件是用于表示系统中设备的文件。例如，硬盘、终端、打印机等设备在文件系统中都有对应的设备文件。
        * **套接字**（Sockets）：套接字是用于进程间通信的特殊文件。
        * **管道**（Pipes）：管道也是一种特殊的文件，用于进程间通信。
        * 所以，当我们说一个文件是"普通文件"时，我们通常是指它不是目录、符号链接、设备文件、套接字或管道，而是包含数据的文件。
* 检查是否有读权限：`S_IRUSR & sbuf.st_mode`

#### clienterror函数：服务器给客户端返回报错信息

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-01-34.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-00-45.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-02-43.png)

```c
/*
 * clienterror - returns an error message to the client
 */
/* $begin clienterror */
// 发送一个 HTTP 响应到客户端，在响应行中包含相应的状态码和状态消息，响应主体中包含一个HTML文件，向浏览器的用户解释这个错误
void clienterror(int fd, char *cause, char *errnum,
                 char *shortmsg, char *longmsg)
{
    char buf[MAXLINE];

    /* Print the HTTP response headers */
    sprintf(buf, "HTTP/1.0 %s %s\r\n", errnum, shortmsg); // 错误类型编号以及短提示
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-type: text/html\r\n\r\n"); // 响应主体中内容的MIME类型
    Rio_writen(fd, buf, strlen(buf));

    /* Print the HTTP response body */
    sprintf(buf, "<html><title>Tiny Error</title>"); // 响应主体
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "<body bgcolor="
                 "ffffff"
                 ">\r\n");
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "%s: %s\r\n", errnum, shortmsg); // 错误类型编号以及短提示
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "<p>%s: %s\r\n", longmsg, cause); // 长提示以及错误原因(未实现的方法、未找到的文件等)
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "<hr><em>The Tiny Web server</em>\r\n");
    Rio_writen(fd, buf, strlen(buf));
}
/* $end clienterror */
```

#### read_requesthdrs函数：读取请求报头并忽略

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-03-03.png)

```c
/*
 * read_requesthdrs - read HTTP request headers
 */
/* $begin read_requesthdrs */
// 读请求报头并忽略它们
void read_requesthdrs(rio_t *rp)
{
    char buf[MAXLINE];

    Rio_readlineb(rp, buf, MAXLINE);
    printf("%s", buf);
    // 循环读取直到遇到分隔的空行为止，表示请求报头结束
    while (strcmp(buf, "\r\n"))
    { // line:netp:readhdrs:checkterm
        Rio_readlineb(rp, buf, MAXLINE);
        printf("%s", buf);
    }
    return;
}
/* $end read_requesthdrs */
```

#### parse_uri函数：对uri字符串进行解析

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-03-29.png)

```c
/*
 * parse_uri - parse URI into filename and CGI args
 *             return 0 if dynamic content, 1 if static
 */
/* $begin parse_uri */
// 传入uri字符串，解析uri，解析后若为静态内容则返回1，若为动态内容则返回0
// 解析完uri之后，将filename赋值为文件路径，cgiargs赋值为请求动态内容时uri中传入的CGI参数字符串('?'后面的内容)
int parse_uri(char *uri, char *filename, char *cgiargs)
{
    char *ptr;

    // uri中是否不包含"cgi-bin"(与当前文件同级的一个文件夹，里面是可执行文件，即动态内容)
    if (!strstr(uri, "cgi-bin")) // 不包含"cgi-bin"，则为静态内容
    { /* Static content */       // line:netp:parseuri:isstatic

        strcpy(cgiargs, "");               // line:netp:parseuri:clearcgi // 清空cgiargs(CGI参数字符串)
        strcpy(filename, ".");             // line:netp:parseuri:beginconvert1 // filename="."
        strcat(filename, uri);             // line:netp:parseuri:endconvert1  // filename="./..."
        if (uri[strlen(uri) - 1] == '/')   // line:netp:parseuri:slashcheck // 若末尾字符为"/"，则返回主页文件路径
            strcat(filename, "home.html"); // line:netp:parseuri:appenddefault // filename="./home.html"
        return 1;
    }
    else                    // 包含"cgi-bin"，则为动态内容
    { /* Dynamic content */ // line:netp:parseuri:isdynamic

        ptr = index(uri, '?'); // line:netp:parseuri:beginextract //uri的'?'后接CGI参数字符串
        if (ptr)
        {
            strcpy(cgiargs, ptr + 1); // 将CGI参数字符串复制到cgiargs
            *ptr = '\0';
        }
        else                     // 不存在传入参数
            strcpy(cgiargs, ""); // line:netp:parseuri:endextract // 清空CGI参数字符串cgiargs

        strcpy(filename, "."); // line:netp:parseuri:beginconvert2
        strcat(filename, uri); // line:netp:parseuri:endconvert2 //可执行文件路径
        return 0;
    }
}
/* $end parse_uri */
```

#### serve_static函数：服务器返回静态内容

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-05-27.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-04-05.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-06-05.png)

```c
/*
 * serve_static - copy a file back to the client
 */
/* $begin serve_static */
// 传入参数为连接描述符、文件地址、文件大小，将静态文件内容通过连接描述符发送给客户端
void serve_static(int fd, char *filename, int filesize)
{
    int srcfd;
    char *srcp, filetype[MAXLINE], buf[MAXBUF];

    /* Send response headers to client */
    // 获取文件类型
    get_filetype(filename, filetype); // line:netp:servestatic:getfiletype

    // 响应行
    sprintf(buf, "HTTP/1.0 200 OK\r\n"); // line:netp:servestatic:beginserve
    Rio_writen(fd, buf, strlen(buf));

    // 响应报头
    sprintf(buf, "Server: Tiny Web Server\r\n");
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-length: %d\r\n", filesize); // 文件长度
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-type: %s\r\n\r\n", filetype); // 文件类型
    Rio_writen(fd, buf, strlen(buf));                   // line:netp:servestatic:endserve

    // 响应主体
    /* Send response body to client */
    // 打开文件，得到文件描述符srcfd，O_RDONLY表示以只读方式打开文件
    srcfd = Open(filename, O_RDONLY, 0); // line:netp:servestatic:open

    // 将文件映射到内存，Mmap函数的返回值srcp是映射区的起始地址
    // PROT_READ表示映射区可以被读取，MAP_PRIVATE表示对映射区的修改不会写回原文件
    srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0); // line:netp:servestatic:mmap

    // 关闭文件描述符srcfd，因为文件已经映射到内存，所以不再需要文件描述符
    // 执行这项任务失败将导致潜在的致命的内存泄漏
    Close(srcfd); // line:netp:servestatic:close

    // 将内存中的数据(即文件数据)发送到客户端
    // fd是客户端的文件描述符，srcp是内存中的数据起始地址，filesize是数据的大小
    Rio_writen(fd, srcp, filesize); // line:netp:servestatic:write

    // 解除内存映射，srcp是映射区的起始地址，filesize是映射区的大小
    // 这对于避免潜在的致命的内存泄漏是很重要的
    Munmap(srcp, filesize); // line:netp:servestatic:munmap
}

/*
 * get_filetype - derive file type from file name
 */
// 传入文件路径，解析文件类型，存入到filetype字符串中
void get_filetype(char *filename, char *filetype)
{
    if (strstr(filename, ".html")) // html文件
        strcpy(filetype, "text/html");
    else if (strstr(filename, ".gif")) // gif文件
        strcpy(filetype, "image/gif");
    else if (strstr(filename, ".png")) // png文件
        strcpy(filetype, "image/png");
    else if (strstr(filename, ".jpg")) // jpg文件
        strcpy(filetype, "image/jpeg");
    else // 普通文本文件
        strcpy(filetype, "text/plain");
}
/* $end serve_static */
```

##### 补充：mmap函数

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-14-02.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-14-46.png)

> `#TODO` csapp内存映射部分、mmap函数等 
> 这一部分还得之后再来回顾看一遍，记笔记！

`mmap`函数和一般的文件读取函数（如`read`）都可以将文件的内容读取到内存中，但它们的工作方式有一些重要的区别：
* 内存管理：`mmap`函数将文件直接映射到进程的地址空间，而`read`函数则将文件的内容复制到一个缓冲区。这意味着，使用`mmap`时，你可以直接通过指针访问文件的内容，而无需进行额外的复制操作。这在处理大文件时可以提高效率。
* 延迟加载：当你使用`mmap`映射一个文件时，文件的内容并不会立即加载到内存中。相反，当你访问映射区的某个部分时，系统会自动将对应的文件内容加载到内存中。这种机制被称为按需页面调度（demand paging）。
* 文件共享：`mmap`可以创建一个共享的内存映射，这意味着多个进程可以共享对同一文件的访问。如果一个进程修改了映射区的内容，其他进程可以看到这些修改。而使用`read`函数则无法实现这种共享。
* 内存对齐：`mmap`函数创建的映射区必须以系统页面大小为单位对齐，而`read`函数则没有这个限制。
  
总的来说，`mmap`和`read`各有优势，适用于不同的场景。在处理大文件，需要文件共享，或者希望利用按需页面调度的特性时，mmap可能是更好的选择。在其他情况下，`read`可能更简单、更方便。

#### serve_dynamic函数：服务器返回动态内容

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-06-44.png)

```c
/*
 * serve_dynamic - run a CGI program on behalf of the client
 */
/* $begin serve_dynamic */
void serve_dynamic(int fd, char *filename, char *cgiargs)
{
    char buf[MAXLINE], *emptylist[] = {NULL};

    /* Return first part of HTTP response */
    // 响应行
    sprintf(buf, "HTTP/1.0 200 OK\r\n");
    Rio_writen(fd, buf, strlen(buf));
    // 响应报头
    sprintf(buf, "Server: Tiny Web Server\r\n");
    Rio_writen(fd, buf, strlen(buf));

    // 在子进程中，Fork()函数返回0，在父进程中，Fork()函数返回子进程的PID
    if (Fork() == 0) /* Child */
    {                // line:netp:servedynamic:fork

        /* Real server would set all CGI vars here */ // 一个真正的服务器还会在此处设置其他的 CGI 环境变量
        // 设置环境变量，QUERY_STRING是一个CGI环境变量，通常用于传递给CGI程序的参数
        setenv("QUERY_STRING", cgiargs, 1); // line:netp:servedynamic:setenv

        // 将标准输出重定向到客户端，Dup2()函数会关闭STDOUT_FILENO（也就是标准输出），然后将fd复制到STDOUT_FILENO
        // 这样，当CGI程序向标准输出写入数据时，数据实际上会被发送到客户端
        Dup2(fd, STDOUT_FILENO); /* Redirect stdout to client */ // line:netp:servedynamic:dup2

        // 因为CGI程序运行在子进程的上下文中，它能够访问所有在调用ex­ecve函数之前就存在的打开文件和环境变量
        // 因此，CGI程序写到标准输出上的任何东西都将直接送到客户端进程，不会受到任何来自父进程的干涉
        // 执行CGI程序。Execve()函数会替换当前进程的映像，使其变为filename指定的程序
        // emptylist是传递给新程序的参数列表，environ是新程序的环境变量列表。
        Execve(filename, emptylist, environ); /* Run CGI program */ // line:netp:servedynamic:execve
    }
    // 父进程等待子进程结束。Wait()函数会使父进程阻塞，直到一个子进程结束
    // 当子进程结束时，Wait()函数返回子进程的PID，并通过第一个参数返回子进程的退出状态
    Wait(NULL); /* Parent waits for and reaps child */ // line:netp:servedynamic:wait
}
/* $end serve_dynamic */
```

#### CGI程序：adder.c - 两数相加

![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-08-06.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-08-19.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-21-08-47.png)

```c
/*
 * adder.c - a minimal CGI program that adds two numbers together
 */
/* $begin adder */
#include "csapp.h"

int main(void)
{
    char *buf, *p;
    char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];
    int n1 = 0, n2 = 0;

    /* Extract the two arguments */
    if ((buf = getenv("QUERY_STRING")) != NULL)
    {                         // 从环境变量中读取cgiargs
        p = strchr(buf, '&'); // 根据'&'分割两个参数
        *p = '\0';
        strcpy(arg1, buf);   // 前一个参数
        strcpy(arg2, p + 1); // 后一个参数
        // 转成数字
        n1 = atoi(arg1);
        n2 = atoi(arg2);
    }

    /* Make the response body */
    sprintf(content, "Welcome to add.com: ");
    sprintf(content, "%sTHE Internet addition portal.\r\n<p>", content);
    sprintf(content, "%sThe answer is: %d + %d = %d\r\n<p>",
            content, n1, n2, n1 + n2); // 输出两数相加之和
    sprintf(content, "%sThanks for visiting!\r\n", content);

    /* Generate the HTTP response */
    printf("Connection: close\r\n");
    printf("Content-length: %d\r\n", (int)strlen(content));
    printf("Content-type: text/html\r\n\r\n");
    printf("%s", content);
    fflush(stdout);

    exit(0);
}
/* $end adder */

```

### 效果

#### 初始化服务器
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-34-41.png)

#### 获取主页
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-35-29.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-34-56.png)

#### 获取静态内容
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-36-52.png)
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-37-31.png)

#### 获取动态内容
![](./assets/8.%20lab8-Proxy%20Lab/2023-12-21-20-38-50.png)

#### 服务器端打印的HTTP请求内容

```shell
Accepted connection from (localhost, 59822)
GET / HTTP/1.1
Host: localhost:8000
Connection: keep-alive
sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7
```

```shell
Accepted connection from (localhost, 59836)
GET /godzilla.gif HTTP/1.1
Host: localhost:8000
Connection: keep-alive
sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7
```

```shell
Accepted connection from (localhost, 59846)
GET /cgi-bin/adder?123&456 HTTP/1.1
Host: localhost:8000
Connection: keep-alive
sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7
```

## 并发echo服务器

### 基于进程的并发echo服务器

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-15-00-03.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-15-00-27.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-15-00-45.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-15-01-20.png)

基于进程的并发echo服务器：
注意，父进程和子进程都需要关闭他们不再需要的套接字。这是因为在Unix系统中，一个套接字只有在所有引用它的文件描述符都被关闭后，才会真正被关闭。
```c
#include "csapp.h"

void echo(int connfd);

void sigchld_handler(int sig)
{
    // 信号处理函数，用于处理子进程结束时发送的SIGCHLD信号。
    // 当一个子进程结束时，父进程需要调用waitpid函数来回收子进程的资源，否则会产生僵尸进程
    while (waitpid(-1, 0, WNOHANG) > 0)
        ;
    return;
}

int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    Signal(SIGCHLD, sigchld_handler);
    listenfd = Open_listenfd(argv[1]); // 从给定端口打开监听描述符

    while (1) // 循环等待客户端连接
    {
        clientlen = sizeof(struct sockaddr_storage);
        // 接收到客户端的连接请求，返回非负连接描述符，并获取sockaddr和addrlen
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        if (Fork() == 0) // 创建一个子进程，对客户端进行响应
        {
            // 子进程关闭监听套接字
            Close(listenfd); /* Child closes its listening socket */
            // 调用echo函数来处理客户端的请求
            echo(connfd); /* Child services client */
            // 关闭与客户端的连接(连接描述符)
            Close(connfd); /* Child closes connection with client */
            // 子进程退出
            exit(0); /* Child exits */
        }
        Close(connfd); /* Parent closes connected socket(important!) */
    }
}
```

echo函数：
```c
// 传入连接描述符
void echo(int connfd)
{
    size_t n;
    char buf[MAXLINE];
    rio_t rio; // 读缓冲区

    // rio_readinitb 函数创建了一个空的读缓冲区，并且将一个打开的文件描述符和这个缓冲区联系起来
    Rio_readinitb(&rio, connfd);
    while ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) // 循环从缓冲区中读取
    {
        printf("server received %d bytes, message: %s\n", (int)n, buf); // 从客户端接收到的字节数

        Rio_writen(connfd, buf, n); // 将接收到的客户端发来的数据再发送回客户端
    }
}
```

#### 进程的优劣

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-15-05-27.png)

### 基于I/O多路复用的并发编程

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-29-07.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-29-51.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-30-47.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-30-59.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-32-05.png)

#### **一次处理一个连接，粗粒度的I/O多路复用**

```c
#include "csapp.h"
void echo(int connfd);
void command(void)
{
    // command函数从标准输入读取一行文本，然后打印出来。
    // 如果读取到 EOF（文件结束标记），则退出程序
    char buf[MAXLINE];
    if (!Fgets(buf, MAXLINE, stdin))
        exit(0);       /* EOF */
    printf("%s", buf); /* Process the input command */
}

int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    fd_set read_set, ready_set; // 描述符集合

    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    // 打开一个监听套接字
    listenfd = Open_listenfd(argv[1]);

    // 初始化一个文件描述符集合（read_set），这个集合包含标准输入和监听套接字。
    // 空描述符集合
    FD_ZERO(&read_set); /* Clear read set */
    // 将标准输入stdin描述符加入描述符集合
    FD_SET(STDIN_FILENO, &read_set); /* Add stdin to read set */
    // 将监听套接字的监听描述符加入描述符集合
    FD_SET(listenfd, &read_set); /* Add listenfd to read set */

    while (1)
    {
        // 更新当前的准备好集合
        ready_set = read_set;
        // 使用select函数等待标准输入或一个客户端连接变得可读
        Select(listenfd + 1, &ready_set, NULL, NULL, NULL);
        // 如果文件描述符fd在set中，FD_ISSET返回非零值，否则返回0
        // 检查标准输入是否已经准备好，变得可读
        if (FD_ISSET(STDIN_FILENO, &ready_set))
            command(); /* Read command line from stdin */
        // 检查客户端连接是否已经准备好，变得可读
        if (FD_ISSET(listenfd, &ready_set))
        {
            clientlen = sizeof(struct sockaddr_storage);
            // 接受客户端连接
            connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
            // 调用echo函数来处理客户端的请求
            echo(connfd); /* Echo client input until EDF */
            // 关闭连接
            Close(connfd);
        }
    }
}
```

#### select函数

`select`是一个Unix系统调用，用于监视多个文件描述符的I/O状态。它允许程序监视多个文件描述符，等待一个或多个文件描述符准备好进行I/O操作。

`select`函数的原型如下：

```c
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

参数说明：

- `nfds`：**需要监视的文件描述符的数量**，通常设置为所有文件描述符中最大的那个加一。
- `readfds`：需要监视**读状态**的**文件描述符集合**。
- `writefds`：需要监视**写状态**的**文件描述符集合**。
- `exceptfds`：需要监视**错误状态的文件描述符集合**。
- `timeout`：**等待的超时时间**。如果设置为NULL，`select`会一直等待，直到有文件描述符准备好进行I/O操作。

`select`函数会**修改传入的文件描述符集合**（`readfds`，`writefds`，`exceptfds`），以**指示哪些文件描述符已经准备好进行I/O操作**。

`select`函数**返回准备好进行I/O操作的文件描述符的数量**。如果超时，返回0。如果发生错误，返回-1。

当`select`函数返回后，你可以使用`FD_ISSET`宏来检查一个特定的文件描述符是否在文件描述符集合中。如果`FD_ISSET`返回非零值，那么这个文件描述符已经准备好进行相应的I/O操作。

例如，如果你想检查一个文件描述符`fd`是否已经准备好进行读操作，你可以这样做：

```c
if (FD_ISSET(fd, &readfds)) {
    // fd is ready for reading
}
```

注意，每次调用`select`函数后，你都需要重新设置文件描述符集合和`nfds`参数，因为`select`函数会修改这些参数。

#### 基于 I/O 多路复用的并发事件驱动服务器

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-35-20.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-36-02.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-36-25.png)

##### 描述符池定义及主函数

```c
#include "csapp.h"

// 描述符池，保存监听描述符 和 与若干客户端连接时的连接描述符
typedef struct /* Represents a pool of connected descriptors */
{

    int maxfd; /* Largest descriptor in read_set */                 // read_set 中的最大文件描述符
    fd_set read_set; /* Set of all active descriptors */            // 所有活动文件描述符的集合
    fd_set ready_set; /* Subset of descriptors ready for reading */ // 准备好进行读操作的文件描述符的子集
    int nready; /* Number of ready descriptors from select */       // 来自 select 的准备好的文件描述符数量
    int maxi; /* High water index into client array */              // 客户端数组中的高水位索引
    int clientfd[FD_SETSIZE]; /* Set of active descriptors */       // 活动文件描述符的集合
    rio_t clientrio[FD_SETSIZE]; /* Set of active read buffers */   // 活动读缓冲区的集合，每个描述符位置均对应一个读缓冲区
} pool;

// 从各个客户端读取到的累计字节总数
int byte_cnt = 0; /* Counts total bytes received by server */

// 主函数，创建服务器，提供I/O多路复用并发处理客户端请求
int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    static pool pool; // 描述符池
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    listenfd = Open_listenfd(argv[1]); // 从指定端口打开一个监听描述符
    init_pool(listenfd, &pool);        // 初始化描述符池，将监听描述符添加到描述符集合中
    while (1)
    {
        /* Wait for lisening/connected descriptor(s) to become ready */
        pool.ready_set = pool.read_set;
        // select返回值为准备好的描述符数量
        pool.nready = Select(pool.maxfd + 1, &pool.ready_set, NULL, NULL, NULL);

        /* If listening descriptor ready, add new client to pool */
        // 只要监听描述符准备好连接了，则与客户端进行连接，将相应连接描述符添加到池中
        if (FD_ISSET(listenfd, &pool.ready_set))
        {
            clientlen = sizeof(struct sockaddr_storage);
            connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen); // 接受客户端连接，返回一个连接描述符

            add_client(connfd, &pool); // 将连接描述符添加到描述符池中
        }

        /* Echo a text line from each ready connected descriptor */
        // 依次检查描述符池中的所有连接描述符，对每个客户端请求均进行一次响应，即细粒度的I/O多路复用
        check_clients(&pool);
    }
}
```

##### 初始化描述符池以及描述符集合

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-44-36.png)

```c
void init_pool(int listenfd, pool *p)
{
    /* Initially, there are no connected descriptors */
    int i;
    p->maxi = -1;
    for (i = 0; i < FD_SETSIZE; i++)
        p->clientfd[i] = -1;
    /* Initially, listenfd is only member of select read set */
    // 初始时描述符集合中只有一个监听描述符
    // 注意只将监听描述符添加到描述符集合，不添加到描述符池，否则在响应客户端请求时会被作为连接描述符处理
    p->maxfd = listenfd;
    FD_ZERO(&p->read_set);
    FD_SET(listenfd, &p->read_set);
}
```

##### 添加客户端连接描述符到描述符池

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-47-35.png)

```c
// 添加一个与客户端的连接描述符到描述符池中
void add_client(int connfd, pool *p)
{
    int i;
    // 准备好的描述符数量减1，这里减1减去的是监听描述符
    // 将请求连接的客户端的连接描述符添加到描述符池之后，监听描述符就继续重新等待其他客户端连接
    p->nready--;

    for (i = 0; i < FD_SETSIZE; i++) /* Find an available slot */
        if (p->clientfd[i] < 0)      // 遍历描述符池列表，若当前位置值为-1，即未使用过，则为描述符分配当前位置
        {
            /* Add connected descriptor to the pool */
            p->clientfd[i] = connfd;                 // 将描述符池当前位置赋值为当前描述符
            Rio_readinitb(&p->clientrio[i], connfd); // 初始化读取缓存区

            /* Add the descriptor to descriptor set */
            FD_SET(connfd, &p->read_set); // 将当前连接描述符添加到描述符集合中

            // 更新最大的描述符值以及已使用位置的最大索引值
            // 最大描述符值用于在调用select函数时指定传入描述符集合的最大数量
            // 这个最大索引值用于减少在处理客户端请求时对描述符池的遍历次数
            /* Update max descriptor and pool high water mark */
            if (connfd > p->maxfd)
                p->maxfd = connfd;
            if (i > p->maxi)
                p->maxi = i;
            break;
        }
    // 若描述符池已满，则报错
    if (i == FD_SETSIZE) /* Couldn't find an empty slot */
        app_error("add_client error: Too many clients");
}
```

##### 响应客户端请求

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-50-04.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-50-38.png)

```c
void check_clients(pool *p)
{
    int i, connfd, n;
    char buf[MAXLINE];
    rio_t rio;
    // 细粒度的I/O多路复用，每次只对一个逻辑流进行一次处理，防止独占
    // 遍历描述符池，依次处理客户端请求
    for (i = 0; (i <= p->maxi) && (p->nready > 0); i++)
    {
        connfd = p->clientfd[i]; // 获取连接描述符
        rio = p->clientrio[i];   // 获取读缓冲区
        /* If the descriptor is ready, echo a text line from it */
        // 若当前位置存在连接描述符，且连接描述符在描述符集合中，则读取客户端消息，并响应
        if ((connfd > 0) && (FD_ISSET(connfd, &p->ready_set)))
        {
            p->nready--; // 已准备好的描述符数量-1

            if ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) // 从读缓冲区读取客户端消息
            {
                byte_cnt += n; // 从各个客户端读取到的累计字节总数
                printf("Server received %d (%d total) bytes on fd %d\n", n, byte_cnt, connfd);
                Rio_writen(connfd, buf, n); // 响应，这里的响应是将客户端发来消息直接发送回客户端
            }
            else /*EOF detected, remove descriptor from pool */ // 若读取到EOF，则连接终止
            {
                Close(connfd); // 关闭连接
                // FD_CLR 是一个宏，用于从文件描述符集合中移除一个文件描述符
                // 注意，FD_CLR 不会检查 fd 是否在 set 中。如果 fd 不在 set 中，FD_CLR 也不会有任何效果
                FD_CLR(connfd, &p->read_set); // 将连接描述符从描述符集合中移除
                p->clientfd[i] = -1;          // 将描述符池中对应位置置为空
            }
        }
    }
}
```

##### I/O多路复用技术的优劣

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-52-13.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-10-17-52-39.png)

### 基于线程的并发编程

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-32-58.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-33-16.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-36-48.png)

#### 创建线程

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-31-53.png)

#### 终止线程

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-32-17.png)

#### 回收已终止线程的资源

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-38-15.png)

#### 分离线程

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-42-34.png)

#### 初始化线程

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-42-58.png)

#### 基于线程的并发服务器

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-46-49.png)
![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-47-49.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-14-47-36.png)

```c
#include "csapp.h"

// 传入连接描述符
void echo(int connfd)
{
    size_t n;
    char buf[MAXLINE];
    rio_t rio; // 读缓冲区

    // rio_readinitb 函数创建了一个空的读缓冲区，并且将一个打开的文件描述符和这个缓冲区联系起来
    Rio_readinitb(&rio, connfd);
    while ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) // 循环从缓冲区中读取
    {
        printf("server received %d bytes, message: %s\n", (int)n, buf); // 从客户端接收到的字节数

        Rio_writen(connfd, buf, n); // 将接收到的客户端发来的数据再发送回客户端
    }
}

/* Thread routine */
// 新线程的处理逻辑
void *thread(void *vargp)
{
    // 用临时变量存储连接描述符
    int connfd = *((int *)vargp);
    // 线程将自己设置为分离状态，这样当线程结束时，系统会自动回收其资源
    Pthread_detach(pthread_self());
    // 释放空间
    Free(vargp);
    echo(connfd);  // 调用echo函数处理客户端的请求
    Close(connfd); // 关闭连接
    return NULL;
}

int main(int argc, char **argv)
{
    int listenfd, *connfdp;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    pthread_t tid;
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    listenfd = Open_listenfd(argv[1]); // 从给定端口打开监听描述符
    while (1)
    {
        clientlen = sizeof(struct sockaddr_storage);
        // 动态分配，记录线程id
        // 这个指针是动态分配的，以避免在多个线程之间共享同一个栈变量
        connfdp = Malloc(sizeof(int));
        // 接收到客户端的连接请求，返回非负连接描述符，并获取sockaddr和addrlen
        *connfdp = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        // 创建线程，将连接描述符传递给新线程
        // 新线程的参数是一个指向连接文件描述符的指针
        Pthread_create(&tid, NULL, thread, connfdp);
    }
}
```

#### 基于预线程化的并发服务器

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-20-31-52.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-20-32-19.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-20-32-56.png)

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-20-33-56.png)

##### 生产者消费者模式

sbuf.h：

```c
#include "csapp.h"

typedef struct
{
    int *buf; /* Buffer array */                    // 缓冲区
    int n; /* Maximum number of slots */            // 缓冲区总槽数
    int front; /* buf[(front+1)%n] is first item */ // 缓冲区头部
    int rear; /* buf[rear%n] is last item */        // 缓冲区尾部
    sem_t mutex; /* Protects accesses to buf */     // 二元信号量，用来保证对缓冲区的互斥访问
    sem_t slots; /* Counts available slots */       // 缓冲区当前可用槽数
    sem_t items; /* Counts available items */       // 缓冲区中可用项目数
} sbuf_t;

/* Create an empty, bounded, shared FIFO buffer with n slots */ // 初始化一个大小为n的缓冲区
void sbuf_init(sbuf_t *sp, int n);

/* Clean up buffer sp */ // 释放缓冲区
void sbuf_deinit(sbuf_t *sp);

/* Insert item onto the rear of shared buffer sp */ // 生产者，向缓冲区插入新项
void sbuf_insert(sbuf_t *sp, int item);

/*Remove and return the first item from buffer sp */ // 消费者，从缓冲区获取项
int sbuf_remove(sbuf_t *sp);
```

sbuf.c：

```c
#include "sbuf.h"

/* Create an empty, bounded, shared FIFO buffer with n slots */ // 初始化一个大小为n的缓冲区
void sbuf_init(sbuf_t *sp, int n)
{
    sp->buf = Calloc(n, sizeof(int));                                    // 缓冲区长度为n
    sp->n = n; /* Buffer holds max of n items */                         // 缓冲区总槽数为n
    sp->front = sp->rear = 0; /* Empty buffer iff front == rear */       // 缓冲区首部和尾部
    Sem_init(&sp->mutex, 0, 1); /* Binary semaphore for locking */       // 二元信号量，保证对缓冲区的互斥访问
    Sem_init(&sp->slots, 0, n); /* Initially, buf has n empty slots */   // 缓冲区可用槽数，初始化为总槽数n
    Sem_init(&sp->items, 0, 0); /* Initially, buf has zero data items */ // 缓冲区可用项目数，初始化为0
}

/* Clean up buffer sp */ // 释放缓冲区
void sbuf_deinit(sbuf_t *sp)
{
    Free(sp->buf);
}

/* Insert item onto the rear of shared buffer sp */ // 生产者，向缓冲区插入新项
void sbuf_insert(sbuf_t *sp, int item)
{
    P(&sp->slots); /* Wait for available slot */ // 先判断可用槽数信号量并-1，若为0，则阻塞
    P(&sp->mutex); /* Lock the buffer */         // 二元互斥信号量，加锁
    sp->buf[(++sp->rear) % (sp->n)] = item;      /* Insert the item */
    V(&sp->mutex); /* Unlock the buffer */       // 二元互斥信号量，解锁、通知
    V(&sp->items); /* Announce available item */ // 判断可用项目数信号量并+1，若为0，则通知消费者
}

/*Remove and return the first item from buffer sp */ // 消费者，从缓冲区获取项
int sbuf_remove(sbuf_t *sp)
{
    int item;
    P(&sp->items); /* Wait for available item */ // 先判断可用项目数信号量并-1，若为0，则阻塞
    P(&sp->mutex); /* Lock the buffer */         // 二元互斥信号量，加锁
    item = sp->buf[(++sp->front) % (sp->n)];     /* Remove the item */
    V(&sp->mutex); /* Unlock the buffer */       // 二元互斥信号量，解锁、通知
    V(&sp->slots); /* Announce available slot */ // 判断可用槽数数信号量并+1，若为0，则通知生产者
    return item;
}
```

##### 并发服务器

echoserver-pre.c

```c
#include "sbuf.h"

#define NTHREADS 4
#define SBUFSIZE 16

static int byte_cnt; /* Byte counter */
static sem_t mutex;  /* and the mutex that protects it */
sbuf_t sbuf;         /* Shared buffer of connected descriptors */

static void init_echo_cnt(void)
{
    Sem_init(&mutex, 0, 1);
    byte_cnt = 0;
}

void echo_cnt(int connfd)
{
    int n;
    char buf[MAXLINE];
    rio_t rio;
    // pthread_once_t once = PTHREAD_ONCE_INIT;和Pthread_once(&once, init_echo_cnt);
    // 这两行代码确保init_echo_cnt函数只被执行一次。这是一种常见的模式，用于初始化只需要进行一次的操作，例如初始化互斥锁。
    static pthread_once_t once = PTHREAD_ONCE_INIT;
    Pthread_once(&once, init_echo_cnt);

    Rio_readinitb(&rio, connfd); // 初始化读缓冲区
    // 从读缓冲区读取客户端发来的请求
    while ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0)
    {
        P(&mutex); // 对 更新byte_cnt变量和打印输出 进行加锁保护
        byte_cnt += n;
        printf("server received %d (%d total) bytes on fd %d\n", n, byte_cnt, connfd);
        V(&mutex);
        Rio_writen(connfd, buf, n); // 响应客户端
    }
}

// 新线程的处理逻辑，
void *thread(void *vargp)
{
    Pthread_detach(pthread_self()); // 线程分离

    while (1) // 循环处理，获取描述符缓存区中的连接描述符，然后读取客户端请求并响应
    {
        int connfd = sbuf_remove(&sbuf); /* Remove connfd from buffer */ // 从描述符缓冲区中获取一个连接描述符
        echo_cnt(connfd); /* Service client */                           // 响应客户端请求
        Close(connfd);                                                   // 关闭连接
    }
}

int main(int argc, char **argv)
{
    int i, listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    pthread_t tid;
    if (argc != 2)
    {
        fprintf(stderr, "usage : %s <port>\n", argv[0]);
        exit(0);
    }
    listenfd = Open_listenfd(argv[1]); // 从指定端口打开监听描述符
    sbuf_init(&sbuf, SBUFSIZE);        // 初始化生产消费者模式缓冲区
    // 创建多个线程并发等待获取缓冲区中的连接描述符
    for (i = 0; i < NTHREADS; i++) /* Create worker threads */
        Pthread_create(&tid, NULL, thread, NULL);
    while (1)
    {
        clientlen = sizeof(struct sockaddr_storage);
        // 接受客户端连接，得到连接描述符
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        // 将连接描述符插入到描述符缓冲区中
        sbuf_insert(&sbuf, connfd); /* Insert connfd in buffer */
    }
}
```

![](./assets/8.%20lab8-Proxy%20Lab/2024-01-11-20-40-54.png)

# Proxy Lab

A Web proxy is a program that acts as a middleman between a Web browser and an end server. Instead of contacting the end server directly to get a Web page, the browser contacts the proxy, which forwards the request on to the end server. When the end server replies to the proxy, the proxy sends the reply on to the browser.

Web代理是一个在Web浏览器和终端服务器之间充当中间人的程序。浏览器不是直接联系终端服务器来获取Web页面，而是联系代理，代理将请求转发到终端服务器。当终端服务器回复代理时，代理将回复发送到浏览器。

Proxies are useful for many purposes. Sometimes proxies are used in firewalls, so that browsers behind a firewall can only contact a server beyond the firewall via the proxy. Proxies can also act as anonymizers: by stripping requests of all identifying information, a proxy can make the browser anonymous to Web servers. Proxies can even be used to cache web objects by storing local copies of objects from servers then responding to future requests by reading them out of its cache rather than by communicating again with remote servers.

代理在很多方面都很有用。有时在防火墙中使用代理，因此防火墙后的浏览器只能通过代理与防火墙外的服务器联系。代理还可以充当匿名器:通过剥离所有标识信息的请求，代理可以使浏览器对Web服务器匿名。代理甚至可以通过存储来自服务器的对象的本地副本来缓存web对象，然后通过从其缓存中读取它们来响应未来的请求，而不是再次与远程服务器通信。

In this lab, you will write a simple HTTP proxy that caches web objects. For the first part of the lab, you will set up the proxy to accept incoming connections, read and parse requests, forward requests to web servers, read the servers’ responses, and forward those responses to the corresponding clients. This first part will involve learning about basic HTTP operation and how to use sockets to write programs that communicate over network connections. In the second part, you will upgrade your proxy to deal with multiple concurrent connections. This will introduce you to dealing with concurrency, a crucial systems concept. In the third and last part, you will add caching to your proxy using a simple main memory cache of recently accessed web content.

在这个实验中，你将编写一个简单的HTTP代理来缓存web对象。在实验的第一部分，你将设置代理来接受传入的连接，读取和解析请求，将请求转发到web服务器，读取服务器的响应，并将这些响应转发到相应的客户端。第一部分将学习基本的HTTP操作，以及如何使用套接字编写通过网络连接进行通信的程序。在第二部分中，您将升级代理以处理多个并发连接。这将向您介绍如何处理并发，这是一个关键的系统概念。在第三部分也是最后一部分中，您将使用最近访问的web内容的简单主内存缓存向代理添加缓存。

## Part I: Implementing a sequential web proxy

The first step is implementing a basic sequential proxy that handles HTTP/1.0 GET requests. Other requests type, such as POST, are strictly optional.

第一步是实现处理HTTP/1.0 GET请求的基本顺序代理。其他请求类型(如POST)严格来说是可选的。

When started, your proxy should listen for incoming connections on a port whose number will be specified on the command line. Once a connection is established, your proxy should read the entirety of the request from the client and parse the request. It should determine whether the client has sent a valid HTTP request; if so, it can then establish its own connection to the appropriate web server then request the object the client specified. Finally, your proxy should read the server’s response and forward it to the client.

启动后，您的代理应该侦听端口上的传入连接，端口的编号将在命令行中指定。一旦建立了连接，您的代理应该从客户端读取整个请求并解析请求。它应该确定客户端是否发送了一个有效的HTTP请求;如果是这样，它可以建立自己到适当web服务器的连接，然后请求客户端指定的对象。最后，您的代理应该读取服务器的响应并将其转发给客户端。

### 4.1 HTTP/1.0 GET requests

When an end user enters a URL such as http://www.cmu.edu/hub/index.html into the address bar of a web browser, the browser will send an HTTP request to the proxy that begins with a line that might resemble the following:
当终端用户在web浏览器的地址栏中输入URL(例如http://www.cmu.edu/hub/index.html)时，浏览器将向代理发送一个HTTP请求，该请求以一行开头，可能类似于以下内容:
```GET http://www.cmu.edu/hub/index.html HTTP/1.1```

In that case, the proxy should parse the request into at least the following fields: the hostname, www.cmu.edu;and the path or query and everything following it, /hub/index.html. That way, the proxy can determine that it should open a connection to www.cmu.edu and send an HTTP request of its own starting with a line of the following form:
在这种情况下，代理应该将请求解析为至少以下字段:主机名，www.cmu.edu;路径或查询和它后面的所有东西，/hub/index.html。这样，代理可以确定它应该打开一个连接到www.cmu.edu，并发送一个自己的HTTP请求，以以下形式的行开头:
```GET /hub/index.html HTTP/1.0```

Note that all lines in an HTTP request end with a carriage return, ‘\r’, followed by a newline, ‘\n’. Also important is that every HTTP request is terminated by an empty line: "\r\n".

请注意，HTTP请求中的所有行都以回车'\r'结束，后跟一个换行'\n'。同样重要的是，每个HTTP请求都以空行"\r\n"结束。

You should notice in the above example that the web browser’s request line ends with HTTP/1.1, while the proxy’s request line ends with HTTP/1.0. Modern web browsers will generate HTTP/1.1 requests, but your proxy should handle them and forward them as HTTP/1.0 requests.

你应该注意到，在上面的例子中，web浏览器的请求行以HTTP/1.1结束，而代理的请求行以HTTP/1.0结束。现代web浏览器会生成HTTP/1.1请求，但是你的代理应该处理它们并将它们作为HTTP/1.0请求转发。

It is important to consider that HTTP requests, even just the subset of HTTP/1.0 GET requests, can be incredibly complicated. The textbook describes certain details of HTTP transactions, but you should refer to RFC 1945 for the complete HTTP/1.0 specification. Ideally your HTTP request parser will be fully robust according to the relevant sections of RFC 1945, except for one detail: while the specification allows for multiline request fields, your proxy is not required to properly handle them. Of course, your proxy should never prematurely abort due to a malformed request.

重要的是要考虑到HTTP请求，即使只是HTTP/1.0 GET请求的子集，也可能非常复杂。教科书描述了HTTP事务的某些细节，但是您应该参考RFC 1945了解完整的HTTP/1.0规范。理想情况下，根据RFC 1945的相关章节，您的HTTP请求解析器将是完全健壮的，除了一个细节:虽然规范允许多行请求字段，但您的代理不需要正确处理它们。当然，您的代理永远不应该由于错误的请求而过早终止。

### 4.2 Request headers

The important request headers for this lab are the Host, User-Agent, Connection, and Proxy-Connection headers:

* Always send a Host header. While this behavior is technically not sanctioned by the HTTP/1.0 specification, it is necessary to coax sensible responses out of certain Web servers, especially those that use virtual hosting.
    总是发送一个Host头。虽然这种行为在技术上不受HTTP/1.0规范的限制，但有必要从某些Web服务器(特别是那些使用虚拟主机的服务器)中诱导出合理的响应。
    The Host header describes the hostname of the end server. For example, to access http://www.cmu.edu/hub/index.html, your proxy would send the following header:
    主机报头描述了终端服务器的主机名。例如，访问http://www.cmu.edu/hub/index.html，您的代理将发送以下标头:
    ```Host: www.cmu.edu```
    It is possible that web browsers will attach their own Host headers to their HTTP requests. If that is the case, your proxy should use the same Host header as the browser.
    web浏览器可能会将自己的主机头附加到HTTP请求中。如果是这种情况，您的代理应该使用与浏览器相同的Host标头。
* You may choose to always send the following User-Agent header:
    您可以选择始终发送以下User-Agent报头:
    ```
    User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3)
    Gecko/20120305 Firefox/10.0.3
    ```
    The header is provided on two separate lines because it does not fit as a single line in the writeup, but your proxy should send the header as a single line.
    标题是在两个单独的行上提供的，因为它不适合作为一个单独的行在writeup中，但是你的代理应该将标题作为一个单独的行发送。
    The User-Agent header identifies the client (in terms of parameters such as the operating system and browser), and web servers often use the identifying information to manipulate the content they serve. Sending this particular User-Agent: string may improve, in content and diversity, the material that you get back during simple telnet-style testing.
    User-Agent报头标识客户端(根据操作系统和浏览器等参数)，web服务器通常使用标识信息来操作它们所服务的内容。发送这个特定User-Agent:字符串可以在内容和多样性方面改进您在简单的telnet式测试中得到的材料。
* Always send the following Connection header:
    `Connection: close`
* Always send the following Proxy-Connection header:
    `Proxy-Connection: close`
    The Connection and Proxy-Connection headers are used to specify whether a connection will be kept alive after the first request/response exchange is completed. It is perfectly acceptable (and suggested) to have your proxy open a new connection for each request. Specifying close as the value of these headers alerts web servers that your proxy intends to close connections after the first request/response exchange.
    Connection和Proxy-Connection头用于指定在第一次请求/响应交换完成后连接是否保持活动。完全可以接受(并建议)让代理为每个请求打开一个新连接。指定close作为这些标头的值提醒web服务器，您的代理打算在第一次请求/响应交换后关闭连接。

For your convenience, the values of the described User-Agent header is provided to you as a string constant in proxy.c.

为了方便起见，所描述的User-Agent报头的值在proxy.c中作为字符串常量提供给您。

Finally, if a browser sends any additional request headers as part of an HTTP request, your proxy should forward them unchanged.

最后，如果浏览器发送任何额外的请求头作为HTTP请求的一部分，您的代理应该不加修改地转发它们。

### 4.3 Port numbers

There are two significant classes of port numbers for this lab: HTTP request ports and your proxy’s listening port.

本实验有两类重要的端口号:HTTP请求端口和代理的侦听端口。

The HTTP request port is an optional field in the URL of an HTTP request. That is, the URL may be of the form, http://www.cmu.edu:8080/hub/index.html, in which case your proxy should connect to the host www.cmu.edu on port 8080 instead of the default HTTP port, which is port 80. Your proxy must properly function whether or not the port number is included in the URL.

HTTP请求端口是HTTP请求URL中的一个可选字段。也就是说，URL的形式可能是 http://www.cmu.edu:8080/hub/index.html ，在这种情况下，您的代理应该在端口8080上连接到主机 www.cmu.edu，而不是默认的HTTP端口(端口80)。无论URL中是否包含端口号，代理都必须正常工作。

The listening port is the port on which your proxy should listen for incoming connections. Your proxy should accept a command line argument specifying the listening port number for your proxy. For example, with the following command, your proxy should listen for connections on port 15213:

侦听端口是代理应该侦听传入连接的端口。您的代理应该接受指定代理侦听端口号的命令行参数。例如，使用以下命令，您的代理应该侦听端口15213上的连接:
```
linux> ./proxy 15213
```

You may select any non-privileged listening port (greater than 1,024 and less than 65,536) as long as it is not used by other processes. Since each proxy must use a unique listening port and many people will simultaneously be working on each machine, the script port-for-user.pl is provided to help you pick your own personal port number. Use it to generate port number based on your user ID:

您可以选择任何非特权侦听端口(大于1024小于65,536)，只要它没有被其他进程使用。由于每个代理必须使用唯一的侦听端口，并且每台机器上将同时有许多人在工作，因此提供了port-for-user.pl脚本来帮助您选择自己的端口号。使用它来生成基于用户ID的端口号:

```
linux> ./port-for-user.pl droh
droh: 45806
```

The port, p, returned by port-for-user.pl is always an even number. So if you need an additional port number, say for the Tiny server, you can safely use ports p and p + 1. 

port-for-user.pl返回的端口p总是一个偶数。因此，如果您需要一个额外的端口号，比如对于Tiny服务器，您可以安全地使用端口p和p + 1。

Please don’t pick your own random port. If you do, you run the risk of interfering with another user.

请不要随意选择端口。如果这样做，就有可能干扰其他用户。

## Part II: Dealing with multiple concurrent requests

一旦你有了一个工作的顺序代理，你应该改变它以**同时处理多个请求**。实现并发服务器的**最简单方法是为每个新的连接请求生成一个新的线程**。其他设计也是可能的，比如你的教科书第12.5.5节描述的**预线程服务器**。
* 请注意，你的线程应该在分离模式下运行，以避免内存泄漏。
* 在 CS:APP3e 教科书中描述的 `open_clientfd` 和 `open_listenfd` 函数基于现代的、协议独立的 `getaddrinfo` 函数，因此它们是线程安全的。

## Part III: Caching web objects

对于实验的最后一部分，你将**在你的代理中添加一个缓存**，**将最近使用的 Web 对象存储在内存中**。HTTP 实际上定义了一个**相当复杂的模型**，通过该模型，web 服务器**可以给出关于它们提供的对象应如何被缓存的指示**，客户端**可以指定代理应如何使用缓存**。然而，**你的代理将采取一种简化的方法**。

当你的代理**从服务器接收到一个 web 对象时**，它应该**在将对象传输给客户端的同时将其缓存到内存中**。如果**另一个客户端从同一服务器请求同一对象**，你的代理**无需重新连接到服务器；它可以简单地重新发送缓存的对象**。

显然，**如果你的代理要缓存所有曾经请求过的对象**，它**将需要无限的内存**。此外，**因为一些 web 对象比其他对象大**，可能**会出现一个巨大的对象消耗掉整个缓存**，阻止其他对象被缓存的情况。为了避免这些问题，你的代理**应该有一个最大缓存大小和一个最大缓存对象大小**。

### 6.1 Maximum cache size

你的代理的整个缓存应该有以下最大大小：

`MAX_CACHE_SIZE = 1 MiB`

在**计算其缓存的大小时，你的代理只能计算用于存储实际 web 对象的字节**；**任何额外的字节，包括元数据，都应该被忽略**。

### 6.2 Maximum object size

你的代理**只应缓存不超过以下最大大小的 web 对象**：

`MAX_OBJECT_SIZE = 100 KiB`

为了你的方便，这两个大小限制都在 proxy.c 中以宏的形式提供。

实现一个正确的缓存的**最简单方法是为每个活动连接分配一个缓冲区**，并**在从服务器接收数据时累积数据**。如果**缓冲区的大小超过了最大对象大小**，那么**可以丢弃缓冲区**。如果**在超过最大对象大小之前读取了 web 服务器的整个响应**，那么**可以缓存该对象**。使用这种方案，**你的代理用于 web 对象的最大数据量是以下内容**，其中 **T 是活动连接的最大数量**：

`MAX_CACHE_SIZE + T * MAX_OBJECT_SIZE`

### 6.3 Eviction policy

你的代理的缓存应该采用一个接近最近最少使用（LRU）驱逐策略的驱逐策略。它不必严格是 LRU，但应该是相当接近的东西。请注意，**读取对象和写入对象都算作使用对象**。

### 6.4 Synchronization

**访问缓存必须是线程安全的**，确保缓存访问没有竞态条件可能会是这部分实验更有趣的方面。事实上，有一个特殊的要求，即**多个线程必须能够同时从缓存中读取**。当然，**一次只允许一个线程写入缓存**，但这个限制对读取者来说不能存在。

因此，**用一个大的排他锁保护对缓存的访问不是一个可接受的解决方案**。你可能想要探索如何划分缓存，**使用 Pthreads 读写锁，或者使用信号量来实现你自己的读写解决方案**。无论哪种情况，你不必实现一个严格的 LRU 驱逐策略，这将给你在支持多个读取者方面提供一些灵活性。

## 答案

### part 1

直接把tiny.c中的定义和函数复制过来进行修改

新添加一个Uri结构体，用于**保存解析Uri后的信息**，形如"https://hostname:port/path"

`MAX_CACHE_SIZE`和`MAX_OBJECT_SIZE`是**在缓存时使用的参数**

`user_agent_hdr`是**转发客户端请求到服务器时必须添加的请求头字段**

```c
#include <stdio.h>
#include "csapp.h"

struct Uri
{
    char host[MAXLINE]; // hostname
    char port[MAXLINE]; // 端口
    char path[MAXLINE]; // 路径
};

void doit(int fd);
void parse_requesthdrs(rio_t *rp, char *header_forward, char *host);
void parse_uri(char *uri, struct Uri *uri_data);

/* Recommended max cache and object sizes */
#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400

/* You won't lose style points for including this long line in your code */
static const char *user_agent_hdr = "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n";
```

#### main函数

除了添加一行捕获并忽略SIGPIPE信号的处理，其他和tiny web服务器代码完全一致，循环接受客户端连接，并进行处理

```c
/* $begin proxy main */
// 传入参数为端口号，初始化代理服务器，等待接收客户端连接请求
int main(int argc, char **argv)
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    /* Check command line args */
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(1);
    }

    signal(SIGPIPE, SIG_IGN); // 捕获并忽略SIGPIPE信号

    listenfd = Open_listenfd(argv[1]); // 服务器根据端口号打开监听描述符
    while (1)
    { // 循环等待客户端连接
        clientlen = sizeof(clientaddr);
        // 接收客户端连接请求
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        // 获取客户端的ip和端口
        Getnameinfo((SA *)&clientaddr, clientlen, hostname, MAXLINE,
                    port, MAXLINE, 0);
        printf("Accepted connection from (%s, %s)\n", hostname, port);
        // 根据连接描述符，调用doit函数处理一个HTTP事务
        doit(connfd);
        Close(connfd);
    }
}
/* $end proxy main */
```

#### doit函数

添加**转发请求给服务器**以及**将回复转发给客户端**的逻辑

注意题目要求，**对请求头需要单独处理**：
* 如果**接收到一个浏览器请求为 `HTTP/1.1` 版本，则应将它作为 `HTTP/1.0` 请求转发**
* **转发合法的 HTTP 请求**
  * 假设请求为 `GET http://www.cmu.edu/hub/index.html HTTP/1.1`
  * 则主机名为 `www.cmu.edu`
  * 请求的页面为 `/hub/index.html`
  * HTTP 请求每行以 `\r\n` 结束，以一个空行 `\r\n` 结尾
* 代理**转发给服务器的请求的 header 的要求**：
  * Host: 如 Host: www.cmu.edu
  * User-Agent为预定义好的：`User-Agent: User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3`
  * Connection: 必须发送 `Connection: close`
  * Proxy-Connection: 必须发送 `Proxy-Connection: close`

这里分别依次调用`parse_uri`和`parse_requesthdrs`进行**解析uri**和**读取客户端请求头、构建转发给服务器的请求头**

```c
/*
 * doit - handle one HTTP request/forward/response transaction
 */
/* $begin doit */
// 传入参数为与客户端的连接描述符
void doit(int client_fd)
{
    // 从客户端读取、转发给服务器，从服务器读取、回复给客户端所用的缓冲区
    char buf[MAXLINE];
    // 从客户端读取的请求的解析信息
    char method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    // 转发给服务器的请求头信息
    char header_forward[MAXLINE];
    // 分别与客户端和服务器连接时的读缓冲区
    rio_t client_rio, server_rio;

    /* Read request line and headers */
    // 初始化读缓冲区，并与连接描述符绑定
    Rio_readinitb(&client_rio, client_fd);
    // 读取和解析请求行
    if (!Rio_readlineb(&client_rio, buf, MAXLINE)) // line:netp:doit:readrequest
        return;
    printf("%s", buf); // 打印读取的请求行

    // 当终端用户在web浏览器的地址栏中输入URL(例如http://www.cmu.edu/hub/index.html)时
    // 浏览器将向代理发送一个HTTP请求，该请求以一行开头
    // 例如：GET http://www.cmu.edu/hub/index.html HTTP/1.1
    // 从请求行中解析出请求方法、uri以及HTTP版本
    sscanf(buf, "%s %s %s", method, uri, version);

    // 判断请求方法，这里只对GET方法进行处理
    if (strcasecmp(method, "GET"))
    {
        printf("Tiny does not implement this method");
        return;
    }

    struct Uri *uri_data = (struct Uri *)malloc(sizeof(struct Uri));
    /* Parse URI from GET request */
    // 将uri(https://hostname:port/path)解析到uri_data结构体中
    parse_uri(uri, uri_data);

    // 读取请求头并构建转发请求头
    parse_requesthdrs(&client_rio, header_forward, uri_data->host);

    // 连接服务器
    int server_fd = Open_clientfd(uri_data->host, uri_data->port);
    if (server_fd < 0)
    {
        printf("connection failed\n");
        return;
    }

    // 转发给服务器
    Rio_readinitb(&server_rio, server_fd);
    sprintf(buf, "GET %s HTTP/1.0\r\n%s", uri_data->path, header_forward);
    // 发送请求行和请求头
    if (rio_writen(server_fd, buf, strlen(buf)) != strlen(buf))
    {
        fprintf(stderr, "Send request line and header error\n");
        close(server_fd);
        return;
    }

    size_t n;
    // 回复给客户端
    while ((n = Rio_readlineb(&server_rio, buf, MAXLINE)) != 0)
    {
        printf("proxy received %d bytes,then send\n", (int)n);
        Rio_writen(client_fd, buf, n);
    }
    // 关闭服务器描述符
    Close(server_fd);
}
/* $end doit */
```

#### parse_uri函数

* **判断https协议**
* **根据分隔符'//'和':'来分割hostname、port和path，分别进行读取，赋值到结构体中**

```c
/* $begin parse_uri */
// 传入uri字符串，解析uri，将解析到的hostname、port、path赋值到uri_data结构体中
// https://hostname:port/path
void parse_uri(char *uri, struct Uri *uri_data)
{
    if (strstr(uri, "http://") != uri)
    {
        fprintf(stderr, "only support https protocol!\n");
        exit(0);
    }
    char *hostbase = strstr(uri, "//"); // "//"之后为hostname:port/path

    if (hostbase == NULL) // 没有hostname和端口号，设置默认端口为 80
    {
        char *pathbase = strstr(uri, "/"); // "/"之后为path
        if (pathbase != NULL)
            strcpy(uri_data->path, pathbase); // 赋值path
        strcpy(uri_data->port, "80");         // 赋值端口
        return;
    }
    else
    {
        char *portpose = strstr(hostbase, ":"); // ":"之后为端口号
        if (portpose != NULL)
        {
            int tmp;
            // 从字符串":port/path"中解析出端口号和path，赋值给uri_data结构体
            sscanf(portpose + 1, "%d%s", &tmp, uri_data->path);
            sprintf(uri_data->port, "%d", tmp);
            *portpose = '\0'; // 将":"替换为"\0"，以便后面获取hostname
        }
        else // 没有端口号，设置默认端口为 80
        {
            char *pathbase = strstr(hostbase + 2, "/");
            if (pathbase != NULL)
            {
                strcpy(uri_data->path, pathbase); // 赋值path
                strcpy(uri_data->port, "80");     // 赋值端口
                *pathbase = '\0';                 // 将":"替换为"\0"，以便后面获取hostname
            }
        }
        strcpy(uri_data->host, hostbase + 2); // 赋值hostname
    }
    return;
}
/* $end parse_uri */
```

#### parse_requesthdrs函数

读取客户端的请求头，并构建转发给服务器的请求头

* **Connection 头**、**Proxy-Connection 头**、**User-Agent 头**需要替换为默认值
* **若客户端的请求头中包含host头，则转发该host头，否则将host替换为从uri中解析出的hostname**
* **其他字段全部不做修改，直接转发**

```c
/* $begin parse_requesthdrs */
// 读请求报头并构建转发请求头
void parse_requesthdrs(rio_t *rp, char *header_forward, char *host)
{
    char buf[MAXLINE];

    Rio_readlineb(rp, buf, MAXLINE);
    printf("%s", buf);
    // 循环读取直到遇到分隔的空行为止，表示请求报头结束
    // 若请求头中包含Host头，则需要转发请求头中的host，否则转发解析出的host
    int has_host_flag = 0; // 记录是否遇到 Host 头
    while (strcmp(buf, "\r\n"))
    {
        Rio_readlineb(rp, buf, MAXLINE);
        printf("%s", buf);
        // 如果遇到 Host 头，记录之，后续不再添加 Host 头
        if (!strncasecmp(buf, "Host:", strlen("Host:")))
        {
            has_host_flag = 1;
        }
        // 如果遇到 Connection 头、Proxy-Connection 头、User-Agent 头，直接跳过，后续替换为默认值
        if (!strncasecmp(buf, "Connection:", strlen("Connection:")))
        {
            continue;
        }
        if (!strncasecmp(buf, "Proxy-Connection:", strlen("Proxy-Connection:")))
        {
            continue;
        }
        if (!strncasecmp(buf, "User-Agent:", strlen("User-Agent:")))
        {
            continue;
        }
        // 其他头与 Host 头直接添加到 header_forward 中
        strcat(header_forward, buf);
    }
    // 如果没有 Host 头，添加解析出的 Host 头
    if (!has_host_flag)
    {
        sprintf(buf, "Host: %s\r\n", host);
        strcat(header_forward, buf);
    }
    // 添加 Connection 头、Proxy-Connection 头、User-Agent 头
    strcat(header_forward, "Connection: close\r\n");
    strcat(header_forward, "Proxy-Connection: close\r\n");
    strcat(header_forward, user_agent_hdr);
    // 添加结束行
    strcat(header_forward, "\r\n");
    return;
}
/* $end parse_requesthdrs */
```

#### 测试结果

```shell
(base) wajorrr@LAPTOP-5S31CFGU:~/CSAPP/labs/proxylab$ ./driver.sh 
*** Basic ***
Starting tiny on 3022
Starting proxy on 4581
1: home.html
   Fetching ./tiny/home.html into ./.proxy using the proxy
   Fetching ./tiny/home.html into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
2: csapp.c
   Fetching ./tiny/csapp.c into ./.proxy using the proxy
   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
3: tiny.c
   Fetching ./tiny/tiny.c into ./.proxy using the proxy
   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
4: godzilla.jpg
   Fetching ./tiny/godzilla.jpg into ./.proxy using the proxy
   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
5: tiny
   Fetching ./tiny/tiny into ./.proxy using the proxy
   Fetching ./tiny/tiny into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
Killing tiny and proxy
basicScore: 40/40
```

### part 2

添加线程级并发逻辑，可以是**直接创建新线程然后进行处理**，也可以是**使用生产者消费者模型**，即前面提到的**预线程化并发服务器**，直接按照前面写过的模板套即可，这里使用了预线程化并发服务器

只需添加相关函数，以及适当修改main函数即可

* **添加`sbuf.h`头文件引用**(前面实现生产者消费者模型时已经写过的文件)：
* 定义**并发线程数量**和**生产者消费者使用的缓冲区大小**
```c
#include "sbuf.h"

#define NTHREADS 4
#define SBUFSIZE 16
sbuf_t sbuf; /* Shared buffer of connected descriptors */
```

#### main函数

添加thread函数，以及参照之前在`echoserver-pre.c`中实现的预线程化并发服务器简单修改main函数即可

```c
/* $begin proxy main */
// 新线程的处理逻辑
void *thread(void *vargp)
{
    Pthread_detach(pthread_self()); // 线程分离

    while (1) // 循环处理，获取描述符缓存区中的连接描述符，然后读取客户端请求并响应
    {
        int connfd = sbuf_remove(&sbuf); /* Remove connfd from buffer */ // 从描述符缓冲区中获取一个连接描述符
        doit(connfd); /* Service client */                               // 响应客户端请求
        Close(connfd);                                                   // 关闭连接
    }
}
// 传入参数为端口号，初始化代理服务器，等待接收客户端连接请求
int main(int argc, char **argv)
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    /* Check command line args */
    if (argc != 2)
    {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(1);
    }

    signal(SIGPIPE, SIG_IGN); // 捕获并忽略SIGPIPE信号

    listenfd = Open_listenfd(argv[1]); // 服务器根据端口号打开监听描述符

    sbuf_init(&sbuf, SBUFSIZE); // 初始化生产消费者模式缓冲区
    // 创建多个线程并发等待获取缓冲区中的连接描述符
    pthread_t tid;
    for (int i = 0; i < NTHREADS; i++) /* Create worker threads */
        Pthread_create(&tid, NULL, thread, NULL);
    while (1)
    { // 循环等待客户端连接
        clientlen = sizeof(clientaddr);
        // 接收客户端连接请求
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        // 获取客户端的ip和端口
        Getnameinfo((SA *)&clientaddr, clientlen, hostname, MAXLINE,
                    port, MAXLINE, 0);
        printf("Accepted connection from (%s, %s)\n", hostname, port);
        // 将连接描述符插入到描述符缓冲区中
        sbuf_insert(&sbuf, connfd); /* Insert connfd in buffer */
    }
}
/* $end proxy main */
```

#### 测试结果

```shell
(base) wajorrr@LAPTOP-5S31CFGU:~/CSAPP/labs/proxylab$ ./driver.sh 
*** Basic ***
Starting tiny on 28664
Starting proxy on 11337
1: home.html
   Fetching ./tiny/home.html into ./.proxy using the proxy
   Fetching ./tiny/home.html into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
2: csapp.c
   Fetching ./tiny/csapp.c into ./.proxy using the proxy
   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
3: tiny.c
   Fetching ./tiny/tiny.c into ./.proxy using the proxy
   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
4: godzilla.jpg
   Fetching ./tiny/godzilla.jpg into ./.proxy using the proxy
   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
5: tiny
   Fetching ./tiny/tiny into ./.proxy using the proxy
   Fetching ./tiny/tiny into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
Killing tiny and proxy
basicScore: 40/40

*** Concurrency ***
Starting tiny on port 2372
Starting proxy on port 3046
Starting the blocking NOP server on port 14685
Trying to fetch a file from the blocking nop-server
Fetching ./tiny/home.html into ./.noproxy directly from Tiny
Fetching ./tiny/home.html into ./.proxy using the proxy
Checking whether the proxy fetch succeeded
Success: Was able to fetch tiny/home.html from the proxy.
Killing tiny, proxy, and nop-server
concurrencyScore: 15/15
```

这里./driver.sh的python版本有问题，需要修改第301行：
```shell
./nop-server.py ${nop_port} &> /dev/null &
```
改为
```
python3 nop-server.py ${nop_port} &> /dev/null &
```

### part 3

这里添加的缓存十分简易，但是文档中提到了实际浏览器和https协议使用的缓存非常复杂，有机会可以去看看

测试点也十分简陋，没有检查一些比较复杂的边界情况，只是单纯检查了一下是否建立了缓存

没什么好说的，**添加一个`cache.h`和`cache.c`**，然后**main函数里面添加一个`cache_init`**，**doit函数里面添加查找缓存和插入缓存即可**

#### cache.h和cache.c

cache.h
```c
#include "csapp.h"

/* Recommended max cache and object sizes */
#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400

typedef struct cache_block
{
    char url[MAXLINE];
    char content[MAX_OBJECT_SIZE];
    int content_size;
    int last_used;
} cache_block;

typedef struct cache_t
{
    cache_block blocks[MAX_CACHE_SIZE / MAX_OBJECT_SIZE];
    int block_count;
    int capacity;
} cache_t;

// 缓存，定义为全局变量
static cache_t cache;
// 信号量，分别用于实现全局变量并发锁、读写锁
static sem_t mutex, rw_mutex;
// 线程共享变量
static int readcnt, timestamp;

void cache_init();
int find_cache(rio_t *rio, char *url);
void insert_cache(char *url, char *content, int content_size);
```

cache.c

```c
#include "cache.h"

void cache_init()
{
    cache.block_count = 0;
    cache.capacity = MAX_CACHE_SIZE / MAX_OBJECT_SIZE;
    timestamp = 0;
    readcnt = 0;
    sem_init(&mutex, 0, 1);
    sem_init(&rw_mutex, 0, 1);
}

int find_cache(rio_t *rio, char *url)
{
    // 使用全局变量 readcnt，需要加锁
    P(&mutex);
    readcnt++;
    // 第一个读者需要加读写锁，保证不会有写者同时访问，同时允许其他读者访问
    if (readcnt == 1)
    {
        P(&rw_mutex);
    }
    V(&mutex); // 释放全局变量 readcnt 的访问权
    int flag = 0;
    for (int i = 0; i < cache.capacity; i++)
    {
        if (strcmp(cache.blocks[i].url, url) == 0)
        {
            // 更新时间戳，也是全局变量，需要加锁
            P(&mutex);
            cache.blocks[i].last_used = timestamp++;
            V(&mutex);
            // 直接将缓存内容发送到客户端
            rio_writen(rio->rio_fd, cache.blocks[i].content, cache.blocks[i].content_size);
            flag = 1;
            break;
        }
    }
    // 同上，使用全局变量 readcnt，需要加锁
    P(&mutex);
    readcnt--;
    // 最后一个读者需要解读写锁，允许写者访问
    if (readcnt == 0)
    {
        V(&rw_mutex);
    }
    V(&mutex);
    return flag;
}

void insert_cache(char *url, char *content, int content_size)
{
    // 修改缓存，需要加读写锁
    P(&rw_mutex);
    // 缓存已满，需要替换最近最少使用的缓存块
    if (cache.block_count == cache.capacity)
    {
        int min = 0;
        for (int i = 1; i < cache.capacity; i++)
        {
            if (cache.blocks[i].last_used < cache.blocks[min].last_used)
                min = i;
        }
        strcpy(cache.blocks[min].url, url);
        memcpy(cache.blocks[min].content, content, content_size);
        cache.blocks[min].content_size = content_size;
        P(&mutex);
        cache.blocks[min].last_used = timestamp++; // 更新时间戳
        V(&mutex);
    }
    else // 缓存未满，直接添加
    {
        strcpy(cache.blocks[cache.block_count].url, url);
        memcpy(cache.blocks[cache.block_count].content, content, content_size);
        cache.blocks[cache.block_count].content_size = content_size;
        // 更新时间戳和已使用的缓存块数量
        P(&mutex);
        cache.blocks[cache.block_count].last_used = timestamp++;
        V(&mutex);
        cache.block_count++;
    }
    V(&rw_mutex); // 释放读写锁
}
```

#### doit函数

这里注意查找缓存和插入缓存之间调用了parse_uri，会修改uri指向的字符串，因此需复制一下原来的uri，保证在查询缓存和插入缓存时传入的url指针指向的是相同的字符串

```c
/*
 * doit - handle one HTTP request/forward/response transaction
 */
/* $begin doit */
// 传入参数为与客户端的连接描述符
void doit(int client_fd)
{
    // 从客户端读取、转发给服务器，从服务器读取、回复给客户端所用的缓冲区
    char buf[MAXLINE];
    // 从客户端读取的请求的解析信息
    char method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    // 转发给服务器的请求头信息
    char header_forward[MAXLINE];
    // 分别与客户端和服务器连接时的读缓冲区
    rio_t client_rio, server_rio;

    /* Read request line and headers */
    // 初始化读缓冲区，并与连接描述符绑定
    Rio_readinitb(&client_rio, client_fd);
    // 读取和解析请求行
    if (!Rio_readlineb(&client_rio, buf, MAXLINE))
        return;
    printf("%s", buf); // 打印读取的请求行

    // 当终端用户在web浏览器的地址栏中输入URL(例如http://www.cmu.edu/hub/index.html)时
    // 浏览器将向代理发送一个HTTP请求，该请求以一行开头
    // 例如：GET http://www.cmu.edu/hub/index.html HTTP/1.1
    // 从请求行中解析出请求方法、uri以及HTTP版本
    sscanf(buf, "%s %s %s", method, uri, version);

    // 判断请求方法，这里只对GET方法进行处理
    if (strcasecmp(method, "GET"))
    {
        printf("Tiny does not implement this method");
        return;
    }

    char cache_url[MAXLINE];
    strcpy(cache_url, uri);
    // 检查当前uri对应的回复是否已被缓存，如果命中缓存，直接返回
    if (find_cache(&client_rio, uri))
    {
        return;
    }

    struct Uri *uri_data = (struct Uri *)malloc(sizeof(struct Uri));
    /* Parse URI from GET request */
    // 将uri(https://hostname:port/path)解析到uri_data结构体中
    parse_uri(uri, uri_data);

    // 读取请求头并构建转发请求头
    parse_requesthdrs(&client_rio, header_forward, uri_data->host);

    // 连接服务器
    int server_fd = Open_clientfd(uri_data->host, uri_data->port);
    if (server_fd < 0)
    {
        printf("connection failed\n");
        return;
    }

    // 转发给服务器
    Rio_readinitb(&server_rio, server_fd);
    sprintf(buf, "GET %s HTTP/1.0\r\n%s", uri_data->path, header_forward);
    // 发送请求行和请求头
    if (rio_writen(server_fd, buf, strlen(buf)) != strlen(buf))
    {
        fprintf(stderr, "Send request line and header error\n");
        close(server_fd);
        return;
    }

    char cache_buf[MAX_OBJECT_SIZE];
    int tot_cnt = 0;
    size_t n;
    // 回复给客户端
    while ((n = Rio_readlineb(&server_rio, buf, MAXLINE)) != 0)
    {
        tot_cnt += n;
        // 若回复的内容长度小于最大缓存长度，则累加到缓冲区中
        if (tot_cnt < MAX_OBJECT_SIZE)
        {
            strcat(cache_buf, buf);
        }
        printf("proxy received %d bytes,then send\n", (int)n);
        Rio_writen(client_fd, buf, n);
    }
    // 若回复的内容长度小于最大缓存长度，则将缓冲区累加的内容添加到缓存
    if (tot_cnt < MAX_OBJECT_SIZE)
    {
        insert_cache(cache_url, cache_buf, tot_cnt);
    }
    // 关闭服务器描述符
    Close(server_fd);
}
/* $end doit */
```

#### 测试结果

```shell
(base) wajorrr@LAPTOP-5S31CFGU:~/CSAPP/labs/proxylab$ ./driver.sh 
*** Basic ***
Starting tiny on 33671
Starting proxy on 11975
1: home.html
   Fetching ./tiny/home.html into ./.proxy using the proxy
   Fetching ./tiny/home.html into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
2: csapp.c
   Fetching ./tiny/csapp.c into ./.proxy using the proxy
   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
3: tiny.c
   Fetching ./tiny/tiny.c into ./.proxy using the proxy
   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
4: godzilla.jpg
   Fetching ./tiny/godzilla.jpg into ./.proxy using the proxy
   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
5: tiny
   Fetching ./tiny/tiny into ./.proxy using the proxy
   Fetching ./tiny/tiny into ./.noproxy directly from Tiny
   Comparing the two files
   Success: Files are identical.
Killing tiny and proxy
basicScore: 40/40

*** Concurrency ***
Starting tiny on port 32888
Starting proxy on port 21819
Starting the blocking NOP server on port 1636
Trying to fetch a file from the blocking nop-server
Fetching ./tiny/home.html into ./.noproxy directly from Tiny
Fetching ./tiny/home.html into ./.proxy using the proxy
Checking whether the proxy fetch succeeded
Success: Was able to fetch tiny/home.html from the proxy.
Killing tiny, proxy, and nop-server
concurrencyScore: 15/15

*** Cache ***
Starting tiny on port 26173
Starting proxy on port 30085
Fetching ./tiny/tiny.c into ./.proxy using the proxy
Fetching ./tiny/home.html into ./.proxy using the proxy
Fetching ./tiny/csapp.c into ./.proxy using the proxy
Killing tiny
Fetching a cached copy of ./tiny/home.html into ./.noproxy
Success: Was able to fetch tiny/home.html from the cache.
Killing proxy
cacheScore: 15/15

totalScore: 70/70
```

## 总结

做这个lab比较核心的是得去看书的最后三章，系统级I/O、网络编程以及并发编程，涉及的知识都不是很深，但是却很多，代码示例也非常多，然后这个lab主要就是让自己了解了一下https协议的实现、web服务器、代理服务器的实现原理，以及代理缓存的一个大致效果，同样也比较简单，但是思想还是比较值得学习的
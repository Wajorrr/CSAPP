## lab4-Architecture Lab

### part A

用Y86-64汇编语言写出下面3个c语言函数的汇编代码：

```cpp
/*
 * Architecture Lab: Part A
 *
 * High level specs for the functions that the students will rewrite
 * in Y86-64 assembly language
 */

/* $begin examples */
/* linked list element */
typedef struct ELE
{
    long val;
    struct ELE *next;
} *list_ptr;

/* sum_list - Sum the elements of a linked list */
long sum_list(list_ptr ls)
{
    long val = 0;
    while (ls)
    {
        val += ls->val;
        ls = ls->next;
    }
    return val;
}

/* rsum_list - Recursive version of sum_list */
long rsum_list(list_ptr ls)
{
    if (!ls)
        return 0;
    else
    {
        long val = ls->val;
        long rest = rsum_list(ls->next);
        return val + rest;
    }
}

/* copy_block - Copy src to dest and return xor checksum of src */
long copy_block(long *src, long *dest, long len)
{
    long result = 0;
    while (len > 0)
    {
        long val = *src++;
        *dest++ = val;
        result ^= val;
        len--;
    }
    return result;
}
/* $end examples */
```

分别命名为 `sum.ys`、`rsum.ys`、`copy.ys`

#### sum.ys

```cpp
/* sum_list - Sum the elements of a linked list */
long sum_list(list_ptr ls)
{
    long val = 0;
    while (ls)
    {
        val += ls->val;
        ls = ls->next;
    }
    return val;
}
```

sum.ys：
```
# Execution begins at address 0
        .pos 0
        irmovq stack,%rsp # 设置栈指针
        call main # 执行main程序
        halt # 结束程序

# Sample linked list
        .align 8
ele1:
        .quad 0x00a 
        .quad ele2
ele2:
        .quad 0x0b0 
        .quad ele3
ele3:
        .quad 0xc00
        .quad 0

main:
        irmovq ele1,%rdi
        call sum_list
        ret

# long sum_list(list_ptr ls)
# %rdi 存放了参数 ls
sum_list:
        xorq %rax,%rax # sum=0
        jmp test
loop:
        mrmovq (%rdi),%rsi # rsi相当于temp，获取ls->val， 
        addq %rsi,%rax # add to sum
        mrmovq 8(%rdi),%rdi # 获取下一个地址
test:
        andq %rdi,%rdi # ls!=nullptr，stop when 0
        jne loop
        ret

# Stack starts here and grows to lower addresses 
        .pos 0x100
stack:

```

测试：
```
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/misc# ./yas sum.ys
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/misc# ./yis sum.yo
Stopped in 26 steps at PC = 0x13.  Status 'HLT', CC Z=1 S=0 O=0
Changes to registers:
%rax:   0x0000000000000000      0x0000000000000cba
%rsp:   0x0000000000000000      0x0000000000000100
%rsi:   0x0000000000000000      0x0000000000000c00

Changes to memory:
0x00f0: 0x0000000000000000      0x000000000000005b
0x00f8: 0x0000000000000000      0x0000000000000013
```

#### rsum.ys

```cpp
/* rsum_list - Recursive version of sum_list */
long rsum_list(list_ptr ls)
{
    if (!ls)
        return 0;
    else
    {
        long val = ls->val;
        long rest = rsum_list(ls->next);
        return val + rest;
    }
}
```

rsum.ys：
```
# Execution begins at address 0
        .pos 0
        irmovq stack,%rsp # 设置栈指针
        call main # 执行main程序
        halt # 结束程序

# Sample linked list
        .align 8
ele1:
        .quad 0x00a 
        .quad ele2
ele2:
        .quad 0x0b0 
        .quad ele3
ele3:
        .quad 0xc00
        .quad 0

main:
        irmovq ele1,%rdi
        call rsum_list
        ret

# long rsum_list(list_ptr ls)
# %rdi 存放了参数 ls
rsum_list:
        pushq %r8 # 只能放在这里，注意区分这个r8和函数返回地址在栈中的push和pop顺序
        # push顺序：push r8(1) push rsp(1) push r8(2) push rsp(2) push r8(3) push rsp(3) push r8(4)
        # pop顺序：pop r8(4) pop rbp(3) pop r8(3) pop rbp(2) pop r8(2) pop rbp(1) pop r8(1)
        andq %rdi,%rdi # ls!=nullptr，stop when 0
        je re
        mrmovq (%rdi),%r8 # ls->val
        mrmovq 8(%rdi),%rdi
        # 这里有一个隐式的pushq 返回地址 pushq %rsp
        call rsum_list
        addq %r8,%rsi # rest+=ls->val
re: 
        popq %r8
        # 这里有一个隐式的popq 返回地址 popq %rbp
        ret

# 上面的这种是第一种思路，每次push结点的val值，返回时pop然后汇总
# 还有另一种思路是每次push结点的地址，返回时将rdi指向的地址还原，然后获取此时rdi指向的val值进行汇总
# 第一种思路是找的知乎上的答案抄的，第二种思路自己写的，犯了两个错误，都写在下面了

# 一种错误的方案，错因，从next结点的地址不能直接获取到前一个结点的地址
# rsum_list:
#         andq %rdi,%rdi # ls!=nullptr，stop when 0
#         je re
          # rdi每次等于一个链表结点的首地址
          # 通过0(rdi)获取结点的第一个8字节，val
          # 通过8(rdi)获取结点的第二个8字节，next
#         mrmovq 8(%rdi),%rdi 
#         call rsum_list
#         mrmovq -8(%rdi),%rdi
          # 通过next结点的-8(rdi)，并不能返回到原来的地址
#         mrmovq (%rdi),%r8 # ls->val
#         addq %r8,%rsi # rest+=ls->val
# re: 
#         ret

# 另一种错误的方案，错因：忽略了函数返回地址的入栈和出栈，把变量的入栈出栈和函数返回地址的入栈出栈弄混在一起了
# rsum_list:
#         andq %rdi,%rdi # ls!=nullptr，stop when 0
#         je re
#         rrmovq %rdi,%r8
#         pushq %r8
#         mrmovq 8(%rdi),%rdi
#         call rsum_list
#         rrmovq %r8,%rdi
#         mrmovq (%rdi),%r9 # ls->val
#         addq %r9,%rsi # rest+=ls->val
# re: 
#         popq %r8
#         ret

# 正确的方案：
# rsum_list:
#         pushq %r8
#         andq %rdi,%rdi # ls!=nullptr，stop when 0
#         je re
#         rrmovq %rdi,%r8
#         mrmovq 8(%rdi),%rdi
#         call rsum_list
#         rrmovq %r8,%rdi
#         mrmovq (%rdi),%r9 # ls->val
#         addq %r9,%rsi # rest+=ls->val
# re: 
#         popq %r8
#         ret

# Stack starts here and grows to lower addresses 
        .pos 0x100
stack:

```

测试：
```
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/misc# ./yas rsum.ys
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/misc# ./yis rsum.yo
Stopped in 38 steps at PC = 0x13.  Status 'HLT', CC Z=0 S=0 O=0
Changes to registers:
%rsp:   0x0000000000000000      0x0000000000000100
%rsi:   0x0000000000000000      0x0000000000000cba

Changes to memory:
0x00b8: 0x0000000000000000      0x0000000000000c00
0x00c0: 0x0000000000000000      0x0000000000000086
0x00c8: 0x0000000000000000      0x00000000000000b0
0x00d0: 0x0000000000000000      0x0000000000000086
0x00d8: 0x0000000000000000      0x000000000000000a
0x00e0: 0x0000000000000000      0x0000000000000086
0x00f0: 0x0000000000000000      0x000000000000005b
0x00f8: 0x0000000000000000      0x0000000000000013
```

#### copy.ys

```cpp
/* copy_block - Copy src to dest and return xor checksum of src */
long copy_block(long *src, long *dest, long len)
{
    long result = 0;
    while (len > 0)
    {
        long val = *src++;
        *dest++ = val;
        result ^= val;
        len--;
    }
    return result;
}
```

copy.ys：
```
# Execution begins at address 0
        .pos 0
        irmovq stack,%rsp # 设置栈指针
        call main # 执行main程序
        halt # 结束程序

.align 8
# Source block
src:
        .quad 0x00a
        .quad 0x0b0
        .quad 0xc00
# Destination block
dest:
        .quad 0x111
        .quad 0x222
        .quad 0x333

main:
        irmovq $3,%rdi # long len
        irmovq dest,%rsi # long *dest
        irmovq src,%rdx # long *src
        irmovq $8,%r8
        irmovq $1,%r9
        call copy_block
        ret

# long copy_block(long *src, long *dest, long len)
copy_block:
        xorq %rax,%rax # long result=0
        jmp test
loop:
        mrmovq (%rdx),%rcx # long val=*src
        addq %r8,%rdx # src++
        rmmovq %rcx,(%rsi) # *dest=val
        addq %r8,%rsi # dest++
        xorq %rcx,%rax # result ^= val
        subq %r9,%rdi # len --
test:
        andq %rdi,%rdi # while(len>0)
        jne loop
        ret

# Stack starts here and grows to lower addresses 
        .pos 0x100
stack:

```

测试：
```
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/misc# ./yas copy.ys
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/misc# ./yis copy.yo
Stopped in 39 steps at PC = 0x13.  Status 'HLT', CC Z=1 S=0 O=0
Changes to registers:
%rax:   0x0000000000000000      0x0000000000000cba
%rcx:   0x0000000000000000      0x0000000000000c00
%rdx:   0x0000000000000000      0x0000000000000030
%rsp:   0x0000000000000000      0x0000000000000100
%rsi:   0x0000000000000000      0x0000000000000048
%r8:    0x0000000000000000      0x0000000000000008
%r9:    0x0000000000000000      0x0000000000000001

Changes to memory:
0x0030: 0x0000000000000111      0x000000000000000a
0x0038: 0x0000000000000222      0x00000000000000b0
0x0040: 0x0000000000000333      0x0000000000000c00
0x00f0: 0x0000000000000000      0x0000000000000083
0x00f8: 0x0000000000000000      0x0000000000000013
```

### part B

实现 `iaddq` 指令，将立即数与寄存器相加
![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-13-08-36.png)

SEQ视图：
![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-12-30-11.png)

两个例子：


![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-12-59-08.png)
![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-13-01-33.png)

回顾一下之前的一些符号定义：

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-12-45-45.png)

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-12-43-28.png)

指令处理阶段：

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-12-50-21.png)

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-12-56-54.png)

于是我们可以写出 `iaddq` 指令顺序实现的计算步骤

| 阶段   | iaddq V,rB                                                                                |
| ------ | ----------------------------------------------------------------------------------------- |
| 取指   | icode:ifun ← M$_1$[PC] <br> rA:rB ← M$_1$[PC+1] <br> valC ← M$_8$[PC+2] <br> valP ← PC+10 |
| 译码   | valB ← R[rB]                                                                              |
| 执行   | valE ← valC+valB <br> Set CC                                                              |
| 访存   |                                                                                           |
| 写回   | R[rB] ← valE                                                                              |
| 更新PC | PC ← valP                                                                                 |

开始对 `seq-full.hcl` 进行修改

可以发现这个文件中已经按照上面说的6个执行阶段分块标记好了

#### 取指阶段

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-14-05-49.png)

#### 译码阶段

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-14-10-20.png)

#### 执行阶段

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-14-17-56.png)

#### 访存阶段

无需修改

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-14-20-34.png)

#### 写回阶段

没有写回阶段的代码块，可能是Y86-64语言中只会涉及到1个寄存器存储运算结果，不需要增加一些控制语句

#### 更新PC阶段

`iaddq` 执行完后正常执行下一条指令，没有转移，无需修改

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-11-14-25-10.png)

#### 测试

* Build a new simulator.
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/seq# make VERSION=full
# Building the seq-full.hcl version of SEQ
../misc/hcl2c -n seq-full.hcl <seq-full.hcl >seq-full.c
gcc -Wall -O2  -I../misc  -o ssim \
        seq-full.c ssim.c ../misc/isa.c  -lm
```

* Testing your solution on a simple Y86-64 program.
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/seq# ./ssim -t ../y86-code/asumi.yo
Y86-64 Processor: seq-full.hcl
137 bytes of code read
IF: Fetched irmovq at 0x0.  ra=----, rb=%rsp, valC = 0x100
IF: Fetched call at 0xa.  ra=----, rb=----, valC = 0x38
Wrote 0x13 to address 0xf8
IF: Fetched irmovq at 0x38.  ra=----, rb=%rdi, valC = 0x18
IF: Fetched irmovq at 0x42.  ra=----, rb=%rsi, valC = 0x4
IF: Fetched call at 0x4c.  ra=----, rb=----, valC = 0x56
Wrote 0x55 to address 0xf0
IF: Fetched xorq at 0x56.  ra=%rax, rb=%rax, valC = 0x0
IF: Fetched andq at 0x58.  ra=%rsi, rb=%rsi, valC = 0x0
IF: Fetched jmp at 0x5a.  ra=----, rb=----, valC = 0x83
IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63
IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0
IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0
IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8
IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff
IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63
IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0
IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0
IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8
IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff
IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63
IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0
IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0
IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8
IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff
IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63
IF: Fetched mrmovq at 0x63.  ra=%r10, rb=%rdi, valC = 0x0
IF: Fetched addq at 0x6d.  ra=%r10, rb=%rax, valC = 0x0
IF: Fetched iaddq at 0x6f.  ra=----, rb=%rdi, valC = 0x8
IF: Fetched iaddq at 0x79.  ra=----, rb=%rsi, valC = 0xffffffffffffffff
IF: Fetched jne at 0x83.  ra=----, rb=----, valC = 0x63
IF: Fetched ret at 0x8c.  ra=----, rb=----, valC = 0x0
IF: Fetched ret at 0x55.  ra=----, rb=----, valC = 0x0
IF: Fetched halt at 0x13.  ra=----, rb=----, valC = 0x0
32 instructions executed
Status = HLT
Condition Codes: Z=1 S=0 O=0
Changed Register State:
%rax:   0x0000000000000000      0x0000abcdabcdabcd
%rsp:   0x0000000000000000      0x0000000000000100
%rdi:   0x0000000000000000      0x0000000000000038
%r10:   0x0000000000000000      0x0000a000a000a000
Changed Memory State:
0x00f0: 0x0000000000000000      0x0000000000000055
0x00f8: 0x0000000000000000      0x0000000000000013
ISA Check Succeeds
```

* Retesting your solution using the benchmark programs.
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/seq# cd ../y86-code; make testssim
Makefile:42: warning: ignoring prerequisites on suffix rule definition
Makefile:45: warning: ignoring prerequisites on suffix rule definition
Makefile:48: warning: ignoring prerequisites on suffix rule definition
Makefile:51: warning: ignoring prerequisites on suffix rule definition
../misc/yas asum.ys
../seq/ssim -t asum.yo > asum.seq
../misc/yas asumr.ys
../seq/ssim -t asumr.yo > asumr.seq
../misc/yas cjr.ys
../seq/ssim -t cjr.yo > cjr.seq
../misc/yas j-cc.ys
../seq/ssim -t j-cc.yo > j-cc.seq
../misc/yas poptest.ys
../seq/ssim -t poptest.yo > poptest.seq
../misc/yas pushquestion.ys
../seq/ssim -t pushquestion.yo > pushquestion.seq
../misc/yas pushtest.ys
../seq/ssim -t pushtest.yo > pushtest.seq
../misc/yas prog1.ys
../seq/ssim -t prog1.yo > prog1.seq
../misc/yas prog2.ys
../seq/ssim -t prog2.yo > prog2.seq
../misc/yas prog3.ys
../seq/ssim -t prog3.yo > prog3.seq
../misc/yas prog4.ys
../seq/ssim -t prog4.yo > prog4.seq
../misc/yas prog5.ys
../seq/ssim -t prog5.yo > prog5.seq
../misc/yas prog6.ys
../seq/ssim -t prog6.yo > prog6.seq
../misc/yas prog7.ys
../seq/ssim -t prog7.yo > prog7.seq
../misc/yas prog8.ys
../seq/ssim -t prog8.yo > prog8.seq
../misc/yas ret-hazard.ys
../seq/ssim -t ret-hazard.yo > ret-hazard.seq
grep "ISA Check" *.seq
asum.seq:ISA Check Succeeds
asumr.seq:ISA Check Succeeds
cjr.seq:ISA Check Succeeds
j-cc.seq:ISA Check Succeeds
poptest.seq:ISA Check Succeeds
prog1.seq:ISA Check Succeeds
prog2.seq:ISA Check Succeeds
prog3.seq:ISA Check Succeeds
prog4.seq:ISA Check Succeeds
prog5.seq:ISA Check Succeeds
prog6.seq:ISA Check Succeeds
prog7.seq:ISA Check Succeeds
prog8.seq:ISA Check Succeeds
pushquestion.seq:ISA Check Succeeds
pushtest.seq:ISA Check Succeeds
ret-hazard.seq:ISA Check Succeeds
rm asum.seq asumr.seq cjr.seq j-cc.seq poptest.seq pushquestion.seq pushtest.seq prog1.seq prog2.seq prog3.seq prog4.seq prog5.seq prog6.seq prog7.seq prog8.seq ret-hazard.seq
```

* Performing regression tests. 
To test everything except `iaddq` and `leave`:
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/y86-code# cd ../ptest; make SIM=../seq/ssim
./optest.pl -s ../seq/ssim 
Simulating with ../seq/ssim
  All 49 ISA Checks Succeed
./jtest.pl -s ../seq/ssim 
Simulating with ../seq/ssim
  All 64 ISA Checks Succeed
./ctest.pl -s ../seq/ssim 
Simulating with ../seq/ssim
  All 22 ISA Checks Succeed
./htest.pl -s ../seq/ssim 
Simulating with ../seq/ssim
  All 600 ISA Checks Succeed
```

To test your implementation of iaddq:
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/ptest# cd ../ptest; make SIM=../seq/ssim TFLAGS=-i
./optest.pl -s ../seq/ssim -i
Simulating with ../seq/ssim
  All 58 ISA Checks Succeed
./jtest.pl -s ../seq/ssim -i
Simulating with ../seq/ssim
  All 96 ISA Checks Succeed
./ctest.pl -s ../seq/ssim -i
Simulating with ../seq/ssim
  All 22 ISA Checks Succeed
./htest.pl -s ../seq/ssim -i
Simulating with ../seq/ssim
  All 756 ISA Checks Succeed
```

ok

### part C

```cpp
/*
 * ncopy - copy src to dst, returning number of positive ints
 * contained in src array.
 */
word_t ncopy(word_t *src, word_t *dst, word_t len)
{
    word_t count = 0;
    word_t val;
    while (len > 0) {
        val = *src++;
        *dst++ = val;
        if (val > 0)
            count++;
        len--;
    }
    return count;
}
```

Your task in Part C is to modify `ncopy.ys` and `pipe-full.hcl` with the goal of making `ncopy.ys` run as fast as possible.


ncopy.ys：

```
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
#
# Describe how and why you modified the baseline code.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
	# Loop header
	xorq %rax,%rax		# count = 0;
	andq %rdx,%rdx		# len <= 0?
	jle Done		# if so, goto Done:

Loop:	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	andq %r10, %r10		# val <= 0?
	jle Npos		# if so, goto Npos:
	irmovq $1, %r10
	addq %r10, %rax		# count++
Npos:	irmovq $1, %r10
	subq %r10, %rdx		# len--
	irmovq $8, %r10
	addq %r10, %rdi		# src++
	addq %r10, %rsi		# dst++
	andq %rdx,%rdx		# len > 0?
	jg Loop			# if so, goto Loop:
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */

```

pipe-full.hcl

```
#/* $begin pipe-all-hcl */
####################################################################
#    HCL Description of Control for Pipelined Y86-64 Processor     #
#    Copyright (C) Randal E. Bryant, David R. O'Hallaron, 2014     #
####################################################################

## Your task is to implement the iaddq instruction
## The file contains a declaration of the icodes
## for iaddq (IIADDQ)
## Your job is to add the rest of the logic to make it work

####################################################################
#    C Include's.  Don't alter these                               #
####################################################################

quote '#include <stdio.h>'
quote '#include "isa.h"'
quote '#include "pipeline.h"'
quote '#include "stages.h"'
quote '#include "sim.h"'
quote 'int sim_main(int argc, char *argv[]);'
quote 'int main(int argc, char *argv[]){return sim_main(argc,argv);}'

####################################################################
#    Declarations.  Do not change/remove/delete any of these       #
####################################################################

##### Symbolic representation of Y86-64 Instruction Codes #############
wordsig INOP 	'I_NOP'
wordsig IHALT	'I_HALT'
wordsig IRRMOVQ	'I_RRMOVQ'
wordsig IIRMOVQ	'I_IRMOVQ'
wordsig IRMMOVQ	'I_RMMOVQ'
wordsig IMRMOVQ	'I_MRMOVQ'
wordsig IOPQ	'I_ALU'
wordsig IJXX	'I_JMP'
wordsig ICALL	'I_CALL'
wordsig IRET	'I_RET'
wordsig IPUSHQ	'I_PUSHQ'
wordsig IPOPQ	'I_POPQ'
# Instruction code for iaddq instruction
wordsig IIADDQ	'I_IADDQ'

##### Symbolic represenations of Y86-64 function codes            #####
wordsig FNONE    'F_NONE'        # Default function code

##### Symbolic representation of Y86-64 Registers referenced      #####
wordsig RRSP     'REG_RSP'    	     # Stack Pointer
wordsig RNONE    'REG_NONE'   	     # Special value indicating "no register"

##### ALU Functions referenced explicitly ##########################
wordsig ALUADD	'A_ADD'		     # ALU should add its arguments

##### Possible instruction status values                       #####
wordsig SBUB	'STAT_BUB'	# Bubble in stage
wordsig SAOK	'STAT_AOK'	# Normal execution
wordsig SADR	'STAT_ADR'	# Invalid memory address
wordsig SINS	'STAT_INS'	# Invalid instruction
wordsig SHLT	'STAT_HLT'	# Halt instruction encountered

##### Signals that can be referenced by control logic ##############

##### Pipeline Register F ##########################################

wordsig F_predPC 'pc_curr->pc'	     # Predicted value of PC

##### Intermediate Values in Fetch Stage ###########################

wordsig imem_icode  'imem_icode'      # icode field from instruction memory
wordsig imem_ifun   'imem_ifun'       # ifun  field from instruction memory
wordsig f_icode	'if_id_next->icode'  # (Possibly modified) instruction code
wordsig f_ifun	'if_id_next->ifun'   # Fetched instruction function
wordsig f_valC	'if_id_next->valc'   # Constant data of fetched instruction
wordsig f_valP	'if_id_next->valp'   # Address of following instruction
boolsig imem_error 'imem_error'	     # Error signal from instruction memory
boolsig instr_valid 'instr_valid'    # Is fetched instruction valid?

##### Pipeline Register D ##########################################
wordsig D_icode 'if_id_curr->icode'   # Instruction code
wordsig D_rA 'if_id_curr->ra'	     # rA field from instruction
wordsig D_rB 'if_id_curr->rb'	     # rB field from instruction
wordsig D_valP 'if_id_curr->valp'     # Incremented PC

##### Intermediate Values in Decode Stage  #########################

wordsig d_srcA	 'id_ex_next->srca'  # srcA from decoded instruction
wordsig d_srcB	 'id_ex_next->srcb'  # srcB from decoded instruction
wordsig d_rvalA 'd_regvala'	     # valA read from register file
wordsig d_rvalB 'd_regvalb'	     # valB read from register file

##### Pipeline Register E ##########################################
wordsig E_icode 'id_ex_curr->icode'   # Instruction code
wordsig E_ifun  'id_ex_curr->ifun'    # Instruction function
wordsig E_valC  'id_ex_curr->valc'    # Constant data
wordsig E_srcA  'id_ex_curr->srca'    # Source A register ID
wordsig E_valA  'id_ex_curr->vala'    # Source A value
wordsig E_srcB  'id_ex_curr->srcb'    # Source B register ID
wordsig E_valB  'id_ex_curr->valb'    # Source B value
wordsig E_dstE 'id_ex_curr->deste'    # Destination E register ID
wordsig E_dstM 'id_ex_curr->destm'    # Destination M register ID

##### Intermediate Values in Execute Stage #########################
wordsig e_valE 'ex_mem_next->vale'	# valE generated by ALU
boolsig e_Cnd 'ex_mem_next->takebranch' # Does condition hold?
wordsig e_dstE 'ex_mem_next->deste'      # dstE (possibly modified to be RNONE)

##### Pipeline Register M                  #########################
wordsig M_stat 'ex_mem_curr->status'     # Instruction status
wordsig M_icode 'ex_mem_curr->icode'	# Instruction code
wordsig M_ifun  'ex_mem_curr->ifun'	# Instruction function
wordsig M_valA  'ex_mem_curr->vala'      # Source A value
wordsig M_dstE 'ex_mem_curr->deste'	# Destination E register ID
wordsig M_valE  'ex_mem_curr->vale'      # ALU E value
wordsig M_dstM 'ex_mem_curr->destm'	# Destination M register ID
boolsig M_Cnd 'ex_mem_curr->takebranch'	# Condition flag
boolsig dmem_error 'dmem_error'	        # Error signal from instruction memory

##### Intermediate Values in Memory Stage ##########################
wordsig m_valM 'mem_wb_next->valm'	# valM generated by memory
wordsig m_stat 'mem_wb_next->status'	# stat (possibly modified to be SADR)

##### Pipeline Register W ##########################################
wordsig W_stat 'mem_wb_curr->status'     # Instruction status
wordsig W_icode 'mem_wb_curr->icode'	# Instruction code
wordsig W_dstE 'mem_wb_curr->deste'	# Destination E register ID
wordsig W_valE  'mem_wb_curr->vale'      # ALU E value
wordsig W_dstM 'mem_wb_curr->destm'	# Destination M register ID
wordsig W_valM  'mem_wb_curr->valm'	# Memory M value

####################################################################
#    Control Signal Definitions.                                   #
####################################################################

################ Fetch Stage     ###################################

## What address should instruction be fetched at
word f_pc = [
	# Mispredicted branch.  Fetch at incremented PC
	M_icode == IJXX && !M_Cnd : M_valA;
	# Completion of RET instruction
	W_icode == IRET : W_valM;
	# Default: Use predicted value of PC
	1 : F_predPC;
];

## Determine icode of fetched instruction
word f_icode = [
	imem_error : INOP;
	1: imem_icode;
];

# Determine ifun
word f_ifun = [
	imem_error : FNONE;
	1: imem_ifun;
];

# Is instruction valid?
bool instr_valid = f_icode in 
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	  IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ };

# Determine status code for fetched instruction
word f_stat = [
	imem_error: SADR;
	!instr_valid : SINS;
	f_icode == IHALT : SHLT;
	1 : SAOK;
];

# Does fetched instruction require a regid byte?
bool need_regids =
	f_icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
		     IIRMOVQ, IRMMOVQ, IMRMOVQ };

# Does fetched instruction require a constant word?
bool need_valC =
	f_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL };

# Predict next value of PC
word f_predPC = [
	f_icode in { IJXX, ICALL } : f_valC;
	1 : f_valP;
];

################ Decode Stage ######################################


## What register should be used as the A source?
word d_srcA = [
	D_icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  } : D_rA;
	D_icode in { IPOPQ, IRET } : RRSP;
	1 : RNONE; # Don't need register
];

## What register should be used as the B source?
word d_srcB = [
	D_icode in { IOPQ, IRMMOVQ, IMRMOVQ  } : D_rB;
	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];

## What register should be used as the E destination?
word d_dstE = [
	D_icode in { IRRMOVQ, IIRMOVQ, IOPQ} : D_rB;
	D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

## What register should be used as the M destination?
word d_dstM = [
	D_icode in { IMRMOVQ, IPOPQ } : D_rA;
	1 : RNONE;  # Don't write any register
];

## What should be the A value?
## Forward into decode stage for valA
word d_valA = [
	D_icode in { ICALL, IJXX } : D_valP; # Use incremented PC
	d_srcA == e_dstE : e_valE;    # Forward valE from execute
	d_srcA == M_dstM : m_valM;    # Forward valM from memory
	d_srcA == M_dstE : M_valE;    # Forward valE from memory
	d_srcA == W_dstM : W_valM;    # Forward valM from write back
	d_srcA == W_dstE : W_valE;    # Forward valE from write back
	1 : d_rvalA;  # Use value read from register file
];

word d_valB = [
	d_srcB == e_dstE : e_valE;    # Forward valE from execute
	d_srcB == M_dstM : m_valM;    # Forward valM from memory
	d_srcB == M_dstE : M_valE;    # Forward valE from memory
	d_srcB == W_dstM : W_valM;    # Forward valM from write back
	d_srcB == W_dstE : W_valE;    # Forward valE from write back
	1 : d_rvalB;  # Use value read from register file
];

################ Execute Stage #####################################

## Select input A to ALU
word aluA = [
	E_icode in { IRRMOVQ, IOPQ } : E_valA;
	E_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ } : E_valC;
	E_icode in { ICALL, IPUSHQ } : -8;
	E_icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

## Select input B to ALU
word aluB = [
	E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
		     IPUSHQ, IRET, IPOPQ } : E_valB;
	E_icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];

## Set the ALU function
word alufun = [
	E_icode == IOPQ : E_ifun;
	1 : ALUADD;
];

## Should the condition codes be updated?
bool set_cc = E_icode == IOPQ &&
	# State changes only during normal operation
	!m_stat in { SADR, SINS, SHLT } && !W_stat in { SADR, SINS, SHLT };

## Generate valA in execute stage
word e_valA = E_valA;    # Pass valA through stage

## Set dstE to RNONE in event of not-taken conditional move
word e_dstE = [
	E_icode == IRRMOVQ && !e_Cnd : RNONE;
	1 : E_dstE;
];

################ Memory Stage ######################################

## Select memory address
word mem_addr = [
	M_icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ } : M_valE;
	M_icode in { IPOPQ, IRET } : M_valA;
	# Other instructions don't need address
];

## Set read control signal
bool mem_read = M_icode in { IMRMOVQ, IPOPQ, IRET };

## Set write control signal
bool mem_write = M_icode in { IRMMOVQ, IPUSHQ, ICALL };

#/* $begin pipe-m_stat-hcl */
## Update the status
word m_stat = [
	dmem_error : SADR;
	1 : M_stat;
];
#/* $end pipe-m_stat-hcl */

## Set E port register ID
word w_dstE = W_dstE;

## Set E port value
word w_valE = W_valE;

## Set M port register ID
word w_dstM = W_dstM;

## Set M port value
word w_valM = W_valM;

## Update processor status
word Stat = [
	W_stat == SBUB : SAOK;
	1 : W_stat;
];

################ Pipeline Register Control #########################

# Should I stall or inject a bubble into Pipeline Register F?
# At most one of these can be true.
bool F_bubble = 0;
bool F_stall =
	# Conditions for a load/use hazard
	E_icode in { IMRMOVQ, IPOPQ } &&
	 E_dstM in { d_srcA, d_srcB } ||
	# Stalling at fetch while ret passes through pipeline
	IRET in { D_icode, E_icode, M_icode };

# Should I stall or inject a bubble into Pipeline Register D?
# At most one of these can be true.
bool D_stall = 
	# Conditions for a load/use hazard
	E_icode in { IMRMOVQ, IPOPQ } &&
	 E_dstM in { d_srcA, d_srcB };

bool D_bubble =
	# Mispredicted branch
	(E_icode == IJXX && !e_Cnd) ||
	# Stalling at fetch while ret passes through pipeline
	# but not condition for a load/use hazard
	!(E_icode in { IMRMOVQ, IPOPQ } && E_dstM in { d_srcA, d_srcB }) &&
	  IRET in { D_icode, E_icode, M_icode };

# Should I stall or inject a bubble into Pipeline Register E?
# At most one of these can be true.
bool E_stall = 0;
bool E_bubble =
	# Mispredicted branch
	(E_icode == IJXX && !e_Cnd) ||
	# Conditions for a load/use hazard
	E_icode in { IMRMOVQ, IPOPQ } &&
	 E_dstM in { d_srcA, d_srcB};

# Should I stall or inject a bubble into Pipeline Register M?
# At most one of these can be true.
bool M_stall = 0;
# Start injecting bubbles as soon as exception passes through memory stage
bool M_bubble = m_stat in { SADR, SINS, SHLT } || W_stat in { SADR, SINS, SHLT };

# Should I stall or inject a bubble into Pipeline Register W?
bool W_stall = W_stat in { SADR, SINS, SHLT };
bool W_bubble = 0;
#/* $end pipe-all-hcl */
```

可以看到就是part1写过的Y86-64汇编程序以及part2修改过的hcl文件

We will express the performance of your function in units of **cycles per element (CPE)**. That is, **if the simulated code requires C cycles to copy a block of N elements, then the CPE is C/N**. The PIPE simulator displays the total number of cycles required to complete the program. The baseline version of the ncopy function running on the standard PIPE simulator with a large 63-element array requires 897 cycles to copy 63 elements, for a CPE of 897/63 = 14.24.

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-13-09-29-04.png)

总之就是对ncopy.ys中的汇编程序进行优化，使得程序执行所需的指令周期尽可能少

#### 使用iaddq对指令进行优化

首先修改pipe-full.hcl文件，和partB基本一样，唯一需要注意的就是iaddq指令条件码的设置，这里用的是条件判断语句，和partB略有不同
![](./assets/4.%20lab4-Architecture%20Lab/2023-08-13-13-08-37.png)

![](./assets/4.%20lab4-Architecture%20Lab/2023-08-13-09-35-58.png)

CPE从15.18降低到了12.70，但离及格线还有不小的差距

```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/pipe# ./benchmark.pl 
        ncopy
0       13
1       27      27.00
2       40      20.00
3       50      16.67
4       63      15.75
5       73      14.60
6       86      14.33
7       96      13.71
8       109     13.62
9       119     13.22
10      132     13.20
11      142     12.91
12      155     12.92
13      165     12.69
14      178     12.71
15      188     12.53
16      201     12.56
17      211     12.41
18      224     12.44
19      234     12.32
20      247     12.35
21      257     12.24
22      270     12.27
23      280     12.17
24      293     12.21
25      303     12.12
26      316     12.15
27      326     12.07
28      339     12.11
29      349     12.03
30      362     12.07
31      372     12.00
32      385     12.03
33      395     11.97
34      408     12.00
35      418     11.94
36      431     11.97
37      441     11.92
38      454     11.95
39      464     11.90
40      477     11.93
41      487     11.88
42      500     11.90
43      510     11.86
44      523     11.89
45      533     11.84
46      546     11.87
47      556     11.83
48      569     11.85
49      579     11.82
50      592     11.84
51      602     11.80
52      615     11.83
53      625     11.79
54      638     11.81
55      648     11.78
56      661     11.80
57      671     11.77
58      684     11.79
59      694     11.76
60      707     11.78
61      717     11.75
62      730     11.77
63      740     11.75
64      753     11.77
Average CPE     12.70
Score   0.0/60.0
```

#### 对循环进行优化

再来看一下cpp代码

```cpp
/*
 * ncopy - copy src to dst, returning number of positive ints
 * contained in src array.
 */
word_t ncopy(word_t *src, word_t *dst, word_t len)
{
    word_t count = 0;
    word_t val;
    while (len > 0) {
        val = *src++;
        *dst++ = val;
        if (val > 0)
            count++;
        len--;
    }
    return count;
}
```

可以看到**每次循环判断len>0一次**，**只对一个元素进行了移动和统计**，这里我们可以**每次判断一次后进行多个元素的移动**，从而**减少条件判断次数**，也能**减少src和dst的++次数**，每次移动多少个元素，就在每次移动完后统一给src和dst加多少，从而**减少指令数量**

```cpp
/*
 * ncopy - copy src to dst, returning number of positive ints
 * contained in src array.
 */
word_t ncopy(word_t *src, word_t *dst, word_t len)
{
    word_t count = 0;
    word_t val;
    while (len > 0) {
        val = *src++;
        *dst++ = val;
        if (val > 0)
            count++;
        len--;
    }
    return count;
}
```

我们假定一次复制x个元素，则程序如下

```cpp
/*
 * ncopy - copy src to dst, returning number of positive ints
 * contained in src array.
 */
word_t ncopy(word_t *src, word_t *dst, word_t len)
{
    word_t count = 0;
    word_t val;
    int x = 4;//进行一次循环判断后复制的元素个数
    while (len > x) {
        val = *src++;
        *dst++ = val;
        if (val > 0)
            count++;
        
        val = *src++;
        *dst++ = val;
        if (val > 0)
            count++;

        val = *src++;
        *dst++ = val;
        if (val > 0)
            count++;
        // ...共x个这样的块
    }
    //剩下不足x个的元素，一个一个进行复制
    while (len > 0) {
        val = *src++;
        *dst++ = val;
        if (val > 0)
            count++;
        len--;
    }
    return count;
}
```

但是Y86-64汇编指令中没有cmp指令，只能判断是否大于、等于、小于0，要如何写这样的循环呢

可行的思路是先将len减去x，然后判断len是否大于等于0

如果大于等于0，则正常进入一次复制x元素的循环，否则，则将len再加上x，然后进入单个复制的循环

x=6时：
```
# Loop header
	# xorq %rax,%rax		# count = 0;
	jmp test1			

Xloop:
	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r10, %r10		# val <= 0?
	jle loop2			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop2:
	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r10, %r10		# val <= 0?
	jle loop3			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop3:
	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r10, %r10		# val <= 0?
	jle loop4			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop4:
	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r10, %r10		# val <= 0?
	jle loop5			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop5:
	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r10, %r10		# val <= 0?
	jle loop6			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop6:
	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r10, %r10		# val <= 0?
	jle test1			# if so, goto test1
	iaddq $1,%rax 		# count++
test1:
	iaddq $-6,%rdx		# len-=6
	jge Xloop			# len>=0?
	iaddq $6,%rdx		# len+=6
	jmp test2
Loop:
	mrmovq (%rdi), %r10	# read val from src...
	rmmovq %r10, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r10, %r10		# val <= 0?
	jle test2			# if so, goto test2:
	iaddq $1,%rax 		# count++
test2:
	iaddq $-1,%rdx # len--
	jge Loop	  # len>=0?
```

测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/pipe# ./benchmark.pl 
        ncopy
0       21
1       30      30.00
2       42      21.00
3       51      17.00
4       63      15.75
5       72      14.40
6       74      12.33
7       83      11.86
8       95      11.88
9       104     11.56
10      116     11.60
11      125     11.36
12      127     10.58
13      136     10.46
14      148     10.57
15      157     10.47
16      169     10.56
17      178     10.47
18      180     10.00
19      189     9.95
20      201     10.05
21      210     10.00
22      222     10.09
23      231     10.04
24      233     9.71
25      242     9.68
26      254     9.77
27      263     9.74
28      275     9.82
29      284     9.79
30      286     9.53
31      295     9.52
32      307     9.59
33      316     9.58
34      328     9.65
35      337     9.63
36      339     9.42
37      348     9.41
38      360     9.47
39      369     9.46
40      381     9.53
41      390     9.51
42      392     9.33
43      401     9.33
44      413     9.39
45      422     9.38
46      434     9.43
47      443     9.43
48      445     9.27
49      454     9.27
50      466     9.32
51      475     9.31
52      487     9.37
53      496     9.36
54      498     9.22
55      507     9.22
56      519     9.27
57      528     9.26
58      540     9.31
59      549     9.31
60      551     9.18
61      560     9.18
62      572     9.23
63      581     9.22
64      593     9.27
Average CPE     10.60
Score   0.0/60.0
```

这里还是每次进行了src++和dst++，可以统一在复制完x个之后进行+x，再修改一下：

```
# Loop header
	# xorq %rax,%rax		# count = 0;
	jmp test1			

Xloop:
	mrmovq (%rdi), %r8	# read val from src...
	rmmovq %r8, (%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop2			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop2:
	mrmovq 8(%rdi), %r8	# read val from src...
	rmmovq %r8, 8(%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop3			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop3:
	mrmovq 16(%rdi), %r8	# read val from src...
	rmmovq %r8, 16(%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop4			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop4:
	mrmovq 24(%rdi), %r8	# read val from src...
	rmmovq %r8, 24(%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop5			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop5:
	mrmovq 32(%rdi), %r8	# read val from src...
	rmmovq %r8, 32(%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop6			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop6:
	mrmovq 40(%rdi), %r8	# read val from src...
	rmmovq %r8, 40(%rsi)	# ...and store it to dst
	iaddq $48,%rdi		# src+=6
	iaddq $48,%rsi		# dst+=6
	andq %r8, %r8		# val <= 0?
	jle test1			# if so, goto test1
	iaddq $1,%rax 		# count++
test1:
	iaddq $-6,%rdx		# len-=6
	jge Xloop			# len>=0?
	iaddq $6,%rdx		# len+=6
	jmp test2
Loop:
	mrmovq (%rdi), %r8	# read val from src...
	rmmovq %r8, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r8, %r8		# val <= 0?
	jle test2			# if so, goto test2:
	iaddq $1,%rax 		# count++
test2:
	iaddq $-1,%rdx # len--
	jge Loop	  # len>=0?
```

测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/pipe# ./benchmark.pl 
        ncopy
0       21
1       30      30.00
2       42      21.00
3       51      17.00
4       63      15.75
5       72      14.40
6       64      10.67
7       73      10.43
8       85      10.62
9       94      10.44
10      106     10.60
11      115     10.45
12      107     8.92
13      116     8.92
14      128     9.14
15      137     9.13
16      149     9.31
17      158     9.29
18      150     8.33
19      159     8.37
20      171     8.55
21      180     8.57
22      192     8.73
23      201     8.74
24      193     8.04
25      202     8.08
26      214     8.23
27      223     8.26
28      235     8.39
29      244     8.41
30      236     7.87
31      245     7.90
32      257     8.03
33      266     8.06
34      278     8.18
35      287     8.20
36      279     7.75
37      288     7.78
38      300     7.89
39      309     7.92
40      321     8.03
41      330     8.05
42      322     7.67
43      331     7.70
44      343     7.80
45      352     7.82
46      364     7.91
47      373     7.94
48      365     7.60
49      374     7.63
50      386     7.72
51      395     7.75
52      407     7.83
53      416     7.85
54      408     7.56
55      417     7.58
56      429     7.66
57      438     7.68
58      450     7.76
59      459     7.78
60      451     7.52
61      460     7.54
62      472     7.61
63      481     7.63
64      493     7.70
Average CPE     9.21
Score   25.7/60.0
```

再试试x=2、3、4、5、7、8、9时的情况
```shell
# x=2
Average CPE     10.08
Score   8.4/60.0
# x=3
Average CPE     9.53
Score   19.3/60.0
# x=4
Average CPE     9.32
Score   23.6/60.0
# x=5
Average CPE     9.24
Score   25.2/60.0
# x=6
Average CPE     9.21
Score   25.7/60.0
# x=7
Average CPE     9.22
Score   25.6/60.0
# x=8
Average CPE     9.25
Score   25.0/60.0
# x=9
Average CPE     9.29
Score   24.2/60.0
```

可以看到x=6的情况CPE是最小的，x更大的情况下CPE反而下降了，这可能是因为x越大，最后剩下的小于x个的元素数量就可能越多，需要单个复制的元素就反而变多了，因此反而增大了CPE，于是我们选取x=6

这样最多剩下5个元素需要逐个复制，我们还可以考虑对剩余的元素再次一次循环优化，可以选取x=2、3、4、5

```shell
# x=2
Average CPE     9.41
Score   21.8/60.0
# x=3
Average CPE     9.42
Score   21.5/60.0
# x=4
Average CPE     9.44
Score   21.2/60.0
# x=5
Average CPE     9.52
Score   19.5/60.0
```

然而效率反而降低了。。因为剩下的元素个数已然不多，而判断剩下的个数是否大于x时还需要先将len-x，再和0进行比较，再将len+x，这样多出了一些无效操作，因此不应再进行第二次循环优化了，或者把第一次循环优化的x设置得非常大，再把第二次循环优化的x设置的小一些？有点过于麻烦了，就不去试了，就先这样吧

#### 消除气泡

看了知乎上说的，自己也搜了下，好像涉及数据冒险相关的知识，这里大概就是说后面指令用到前面指令结果时，前面指令的结果还没产生这种情况，为了避免产生错误，处理器会在硬件上通过阻塞（stall）方式阻止后续指令执行，延迟到有新值以后再执行，从而白白浪费了时间

具体就是下面这两条指令
```
mrmovq (%rdi), %r8
rmmovq %r8, (%rsi)
```

这两条指令之间会产生气泡，通过阻塞来确保结果的正确性

```
mrmovq (%rdi), %r8
bubble
rmmovq %r8, (%rsi)
```

消除方法：插入空指令、其他指令、采用转发等

这里我们可以插入其他的指令，一次多取一个寄存器的值，然后再统一赋值
```
mrmovq (%rdi), %r8
mrmovq 8(%rdi), %r9
rmmovq %r8, (%rsi)
rmmovq %r9, 8(%rsi)
```

于是可以这样修改：
```
# Loop header
	# xorq %rax,%rax		# count = 0;
	jmp test1			

Xloop:
	mrmovq (%rdi), %r8	# read val from src...
	mrmovq 8(%rdi), %r9	# read val from src...
	rmmovq %r8, (%rsi)	# ...and store it to dst
	rmmovq %r9, 8(%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop2			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop2:
	# mrmovq 8(%rdi), %r8	# read val from src...
	# rmmovq %r8, 8(%rsi)	# ...and store it to dst
	andq %r9, %r9		# val <= 0?
	jle loop3			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop3:
	mrmovq 16(%rdi), %r8	# read val from src...
	mrmovq 24(%rdi), %r9	# read val from src...
	rmmovq %r8, 16(%rsi)	# ...and store it to dst
	rmmovq %r9, 24(%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop4			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop4:
	# mrmovq 24(%rdi), %r8	# read val from src...
	# rmmovq %r8, 24(%rsi)	# ...and store it to dst
	andq %r9, %r9		# val <= 0?
	jle loop5			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop5:
	mrmovq 32(%rdi), %r8	# read val from src...
	mrmovq 40(%rdi), %r9	# read val from src...
	rmmovq %r8, 32(%rsi)	# ...and store it to dst
	rmmovq %r9, 40(%rsi)	# ...and store it to dst
	andq %r8, %r8		# val <= 0?
	jle loop6			# if so, goto next loop
	iaddq $1,%rax 		# count++
loop6:
	# mrmovq 40(%rdi), %r8	# read val from src...
	# rmmovq %r8, 40(%rsi)	# ...and store it to dst
	iaddq $48,%rdi		# src+=6
	iaddq $48,%rsi		# dst+=6
	andq %r9, %r9		# val <= 0?
	jle test1			# if so, goto test1
	iaddq $1,%rax 		# count++
test1:
	iaddq $-6,%rdx		# len-=6
	jge Xloop			# len>=0?
	iaddq $6,%rdx		# len+=6
	jmp test2
Loop:
	mrmovq (%rdi), %r8	# read val from src...
	rmmovq %r8, (%rsi)	# ...and store it to dst
	iaddq $8,%rdi		# src++
	iaddq $8,%rsi		# dst++
	andq %r8, %r8		# val <= 0?
	jle test2			# if so, goto test2:
	iaddq $1,%rax 		# count++
test2:
	iaddq $-1,%rdx # len--
	jge Loop	  # len>=0?
```

测试结果：
```shell
root@TABLET-ME3SC21V:/home/wajorrr/CSAPP/labs/archlab/sim/pipe# ./benchmark.pl 
        ncopy
0       21
1       30      30.00
2       42      21.00
3       51      17.00
4       63      15.75
5       72      14.40
6       58      9.67
7       67      9.57
8       79      9.88
9       88      9.78
10      100     10.00
11      109     9.91
12      95      7.92
13      104     8.00
14      116     8.29
15      125     8.33
16      137     8.56
17      146     8.59
18      132     7.33
19      141     7.42
20      153     7.65
21      162     7.71
22      174     7.91
23      183     7.96
24      169     7.04
25      178     7.12
26      190     7.31
27      199     7.37
28      211     7.54
29      220     7.59
30      206     6.87
31      215     6.94
32      227     7.09
33      236     7.15
34      248     7.29
35      257     7.34
36      243     6.75
37      252     6.81
38      264     6.95
39      273     7.00
40      285     7.12
41      294     7.17
42      280     6.67
43      289     6.72
44      301     6.84
45      310     6.89
46      322     7.00
47      331     7.04
48      317     6.60
49      326     6.65
50      338     6.76
51      347     6.80
52      359     6.90
53      368     6.94
54      354     6.56
55      363     6.60
56      375     6.70
57      384     6.74
58      396     6.83
59      405     6.86
60      391     6.52
61      400     6.56
62      412     6.65
63      421     6.68
64      433     6.77
Average CPE     8.38
Score   42.4/60.0
```

至此再在网上找找基本就没有什么其他的优化思路了，再有的话应该就是从hcl文件入手，再为其添加一些条件判断指令这样子的方式了

但是目前分数还是只有42.4，自己看了一下知乎上一个58分的答案，发现原因主要还是在于没有进行第二次循环优化，前面试的时候并非第二次循环优化难以再减少CPE，而是自己做进一步优化的时候还是按照第一次优化的格式在写，要认真去做进一步优化的话，需要根据剩余数的数量再进行条件判断，分别编写逻辑。除此之外，还有前面说的，要把第一次循环优化的x增大，58分的答案在第一次循环优化中x=10，第二次优化再进行条件判断分为剩下的数的数量<4、=4、>4三种情况，再逐一继续细分，继续条件判断，最后为每个分支终点逐一编写逻辑，而不能直接统一单个循环复制

总之思路就是**若干循环优化+消除数据冒险产生的气泡**，想要追求极致的话还需要增加很多的重复代码量，就先不弄了

lab 4完结！